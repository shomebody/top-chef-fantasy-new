=== Server + Client Layouts/Types/Pages Files ===
--- server/package.json ---
{"name": "top-chef-fantasy-server",;"version": "1.0.0",;"description": "Backend server for Top Chef Fantasy application",;"main": "src/index.js",;"type": "module",;"scripts": {"start": "node src/index.js",;"dev": "nodemon src/index.js",;"test": "echo \"Error: no test specified\" && exit 1";},;"dependencies": {"bcryptjs": "2.4.3",;"cors": "2.8.5",;"dotenv": "^16.4.5",;"express": "^4.21.2",;"express-validator": "7.0.1",;"firebase-admin": "12.6.0",;"helmet": "7.1.0",;"jsonwebtoken": "9.0.2",;"morgan": "1.10.0",;"portfinder": "1.0.35",;"socket.io": "^4.7.5",;"winston": "^3.17.0";},;"devDependencies": {"nodemon": "^3.1.0";},;"engines": {"node": ">=22.0.0"}}
--- server/src/config/firebase.js ---
import firebaseAdmin from 'firebase-admin';import dotenv from 'dotenv';import { fileURLToPath } from 'url';import path from 'path';import fs from 'fs';dotenv.config();const __dirname = path.dirname(fileURLToPath(import.meta.url));const serviceAccountPath = path.join(__dirname, '../../firebase-service-account.json');let credential;try {if (fs.existsSync(serviceAccountPath)) {console.log('Using Firebase service account from file');const serviceAccount = JSON.parse(fs.readFileSync(serviceAccountPath, 'utf8'));credential = firebaseAdmin.credential.cert(serviceAccount);} else if (process.env.FIREBASE_SERVICE_ACCOUNT) {console.log('Using Firebase service account from environment variable');const serviceAccount = JSON.parse(process.env.FIREBASE_SERVICE_ACCOUNT);credential = firebaseAdmin.credential.cert(serviceAccount);} else {console.warn('Using application default credentials. Set up proper service account for production.');credential = firebaseAdmin.credential.applicationDefault();};if (!firebaseAdmin.apps.length) {firebaseAdmin.initializeApp({credential,;storageBucket: process.env.FIREBASE_STORAGE_BUCKET;});console.log('Firebase Admin initialized successfully');};} catch (error) {console.error('Error initializing Firebase Admin:', error);process.exit(1);};export const auth = firebaseAdmin.auth();export const db = firebaseAdmin.firestore();export const storage = firebaseAdmin.storage();export default firebaseAdmin
--- server/src/controllers/authController.js ---
import { auth, db } from '../config/firebase.js';import { createLogger, format, transports } from 'winston';import asyncHandler from '../utils/asyncHandler.js';const logger = createLogger({level: process.env.NODE_ENV === 'development' ? 'debug' : 'info',;format: format.combine(;format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),;format.errors({ stack: true }),;format.json();),;transports: [;new transports.Console(),;new transports.File({ filename: 'logs/error.log', level: 'error' }),;new transports.File({ filename: 'logs/combined.log' }),;],;});export const registerUser = asyncHandler(async (req, res) => {const { name, email, password } = req.body;if (!email || !password || !name) {res.status(400);throw new Error('Name, email, and password are required');};if (password.length < 6) {res.status(400);throw new Error('Password must be at least 6 characters');};try {const userSnapshot = await db.collection('users').where('email', '==', email.toLowerCase()).get();if (!userSnapshot.empty) {res.status(400);throw new Error('User already exists');};const userRecord = await auth.createUser({email: email.toLowerCase(),;password,;displayName: name,;});const userId = userRecord.uid;await db.collection('users').doc(userId).set({name,;email: email.toLowerCase(),;avatar: '',;isAdmin: false,;leagues: [],;createdAt: admin.firestore.FieldValue.serverTimestamp(),;});const token = await auth.createCustomToken(userId);res.status(201).json({_id: userId,;name,;email: email.toLowerCase(),;isAdmin: false,;token,;});} catch (error) {logger.error('Registration error:', { message: error.message, stack: error.stack });res.status(400);throw new Error(error.message || 'Invalid user data');};});export const loginUser = asyncHandler(async (req, res) => {const { email } = req.body;if (!email) {res.status(400);throw new Error('Email is required');};try {const userSnapshot = await db.collection('users').where('email', '==', email.toLowerCase()).limit(1).get();if (userSnapshot.empty) {res.status(401);throw new Error('Invalid email');};const userDoc = userSnapshot.docs[0];const userData = userDoc.data();const userId = userDoc.id;const token = await auth.createCustomToken(userId);res.json({_id: userId,;name: userData.name ?? '',;email: userData.email,;isAdmin: userData.isAdmin ?? false,;token,;});} catch (error) {logger.error('Login error:', { message: error.message, stack: error.stack });res.status(401);throw new Error(error.message || 'Invalid email');};});export const getUserProfile = asyncHandler(async (req, res) => {try {const userDoc = await db.collection('users').doc(req.user._id).get();if (!userDoc.exists) {res.status(404);throw new Error('User not found');};const userData = userDoc.data() ?? {};res.json({_id: userDoc.id,;name: userData.name ?? '',;email: userData.email ?? '',;isAdmin: userData.isAdmin ?? false,;avatar: userData.avatar ?? '',;});} catch (error) {logger.error('Get profile error:', { message: error.message, stack: error.stack });res.status(error.status || 500);throw new Error(error.message || 'Failed to get user profile');};});export const updateUserProfile = asyncHandler(async (req, res) => {try {const userRef = db.collection('users').doc(req.user._id);const userDoc = await userRef.get();if (!userDoc.exists) {res.status(404);throw new Error('User not found');};const updates = {};if (req.body.name) updates.name = req.body.name;if (req.body.email) updates.email = req.body.email.toLowerCase();if (req.body.avatar) updates.avatar = req.body.avatar;if (req.body.password) {if (req.body.password.length < 6) {res.status(400);throw new Error('Password must be at least 6 characters');};await auth.updateUser(req.user._id, { password: req.body.password });};if (req.body.name) {await auth.updateUser(req.user._id, { displayName: req.body.name });};await userRef.update(updates);const updatedUserDoc = await userRef.get();const updatedUserData = updatedUserDoc.data() ?? {};const token = await auth.createCustomToken(req.user._id);res.json({_id: updatedUserDoc.id,;name: updatedUserData.name ?? '',;email: updatedUserData.email ?? '',;isAdmin: updatedUserData.isAdmin ?? false,;avatar: updatedUserData.avatar ?? '',;token,;});} catch (error) {logger.error('Update profile error:', { message: error.message, stack: error.stack });res.status(error.status || 500);throw new Error(error.message || 'Failed to update user profile');};});export const getUsers = asyncHandler(async (req, res) => {try {const usersSnapshot = await db.collection('users').get();const users = usersSnapshot.docs.map((doc) => {const userData = doc.data() ?? {};return {_id: doc.id,;name: userData.name ?? '',;email: userData.email ?? '',;isAdmin: userData.isAdmin ?? false,;avatar: userData.avatar ?? '',;};});res.json(users);} catch (error) {logger.error('Get users error:', { message: error.message, stack: error.stack });res.status(500);throw new Error('Failed to get users');};})
--- server/src/controllers/challengeController.js ---
import { db } from '../config/firebase.js';import asyncHandler from '../utils/asyncHandler.js';export const getChallenges = asyncHandler(async (req, res) => {try {const { season } = req.query;let challengesQuery = db.collection('challenges');if (season) {challengesQuery = challengesQuery.where('season', '==', parseInt(season));};const challengesSnapshot = await challengesQuery.orderBy('season').orderBy('week').get();const challenges = [];const chefPromises = [];challengesSnapshot.forEach(doc => {const challenge = {_id: doc.id,;...doc.data();};challenges.push(challenge);});for (const challenge of challenges) {if (challenge.winner) {const winnerDoc = await db.collection('chefs').doc(challenge.winner).get();if (winnerDoc.exists) {challenge.winner = {_id: winnerDoc.id,;name: winnerDoc.data().name,;image: winnerDoc.data().image;};}};if (challenge.topChefs && challenge.topChefs.length > 0) {const topChefDocs = await Promise.all(;challenge.topChefs.map(chefId => db.collection('chefs').doc(chefId).get()););challenge.topChefs = topChefDocs;.filter(doc => doc.exists);.map(doc => ({_id: doc.id,;name: doc.data().name,;image: doc.data().image;}));};if (challenge.bottomChefs && challenge.bottomChefs.length > 0) {const bottomChefDocs = await Promise.all(;challenge.bottomChefs.map(chefId => db.collection('chefs').doc(chefId).get()););challenge.bottomChefs = bottomChefDocs;.filter(doc => doc.exists);.map(doc => ({_id: doc.id,;name: doc.data().name,;image: doc.data().image;}));};if (challenge.eliminatedChef) {const eliminatedChefDoc = await db.collection('chefs').doc(challenge.eliminatedChef).get();if (eliminatedChefDoc.exists) {challenge.eliminatedChef = {_id: eliminatedChefDoc.id,;name: eliminatedChefDoc.data().name,;image: eliminatedChefDoc.data().image;};}}};res.json(challenges);} catch (error) {console.error('Error fetching challenges:', error);res.status(500).json({ message: 'Failed to fetch challenges' });};});export const getChallengeById = asyncHandler(async (req, res) => {try {const challengeDoc = await db.collection('challenges').doc(req.params.id).get();if (!challengeDoc.exists) {res.status(404);throw new Error('Challenge not found');};const challenge = {_id: challengeDoc.id,;...challengeDoc.data();};if (challenge.winner) {const winnerDoc = await db.collection('chefs').doc(challenge.winner).get();if (winnerDoc.exists) {challenge.winner = {_id: winnerDoc.id,;name: winnerDoc.data().name,;image: winnerDoc.data().image;};}};if (challenge.topChefs && challenge.topChefs.length > 0) {const topChefDocs = await Promise.all(;challenge.topChefs.map(chefId => db.collection('chefs').doc(chefId).get()););challenge.topChefs = topChefDocs;.filter(doc => doc.exists);.map(doc => ({_id: doc.id,;name: doc.data().name,;image: doc.data().image;}));};if (challenge.bottomChefs && challenge.bottomChefs.length > 0) {const bottomChefDocs = await Promise.all(;challenge.bottomChefs.map(chefId => db.collection('chefs').doc(chefId).get()););challenge.bottomChefs = bottomChefDocs;.filter(doc => doc.exists);.map(doc => ({_id: doc.id,;name: doc.data().name,;image: doc.data().image;}));};if (challenge.eliminatedChef) {const eliminatedChefDoc = await db.collection('chefs').doc(challenge.eliminatedChef).get();if (eliminatedChefDoc.exists) {challenge.eliminatedChef = {_id: eliminatedChefDoc.id,;name: eliminatedChefDoc.data().name,;image: eliminatedChefDoc.data().image;};}};res.json(challenge);} catch (error) {console.error('Error fetching challenge:', error);res.status(error.status || 500);throw new Error(error.message || 'Failed to fetch challenge');};});export const createChallenge = asyncHandler(async (req, res) => {const {season,;week,;title,;description,;location,;isQuickfire,;guest,;airDate;} = req.body;try {const challengeData = {season: parseInt(season),;week: parseInt(week),;title,;description,;location,;isQuickfire: isQuickfire || false,;guest: guest || '',;winner: null,;topChefs: [],;bottomChefs: [],;eliminatedChef: null,;airDate: new Date(airDate).toISOString(),;status: 'upcoming',;createdAt: new Date().toISOString();};const challengeRef = db.collection('challenges').doc();await challengeRef.set(challengeData);const challenge = {_id: challengeRef.id,;...challengeData;};res.status(201).json(challenge);} catch (error) {console.error('Error creating challenge:', error);res.status(500);throw new Error('Failed to create challenge');};});export const updateChallenge = asyncHandler(async (req, res) => {try {const challengeRef = db.collection('challenges').doc(req.params.id);const challengeDoc = await challengeRef.get();if (!challengeDoc.exists) {res.status(404);throw new Error('Challenge not found');};const updates = {};if (req.body.title !== undefined) updates.title = req.body.title;if (req.body.description !== undefined) updates.description = req.body.description;if (req.body.location !== undefined) updates.location = req.body.location;if (req.body.isQuickfire !== undefined) updates.isQuickfire = req.body.isQuickfire;if (req.body.guest !== undefined) updates.guest = req.body.guest;if (req.body.airDate !== undefined) updates.airDate = new Date(req.body.airDate).toISOString();if (req.body.status !== undefined) updates.status = req.body.status;if (req.body.winner !== undefined) updates.winner = req.body.winner;if (req.body.topChefs !== undefined) updates.topChefs = req.body.topChefs;if (req.body.bottomChefs !== undefined) updates.bottomChefs = req.body.bottomChefs;if (req.body.eliminatedChef !== undefined) updates.eliminatedChef = req.body.eliminatedChef;await challengeRef.update(updates);const updatedChallengeDoc = await challengeRef.get();const updatedChallenge = {_id: updatedChallengeDoc.id,;...updatedChallengeDoc.data();};if (updatedChallenge.winner) {const winnerDoc = await db.collection('chefs').doc(updatedChallenge.winner).get();if (winnerDoc.exists) {updatedChallenge.winner = {_id: winnerDoc.id,;name: winnerDoc.data().name,;image: winnerDoc.data().image;};}};if (updatedChallenge.topChefs && updatedChallenge.topChefs.length > 0) {const topChefDocs = await Promise.all(;updatedChallenge.topChefs.map(chefId => db.collection('chefs').doc(chefId).get()););updatedChallenge.topChefs = topChefDocs;.filter(doc => doc.exists);.map(doc => ({_id: doc.id,;name: doc.data().name,;image: doc.data().image;}));};if (updatedChallenge.bottomChefs && updatedChallenge.bottomChefs.length > 0) {const bottomChefDocs = await Promise.all(;updatedChallenge.bottomChefs.map(chefId => db.collection('chefs').doc(chefId).get()););updatedChallenge.bottomChefs = bottomChefDocs;.filter(doc => doc.exists);.map(doc => ({_id: doc.id,;name: doc.data().name,;image: doc.data().image;}));};if (updatedChallenge.eliminatedChef) {const eliminatedChefDoc = await db.collection('chefs').doc(updatedChallenge.eliminatedChef).get();if (eliminatedChefDoc.exists) {updatedChallenge.eliminatedChef = {_id: eliminatedChefDoc.id,;name: eliminatedChefDoc.data().name,;image: eliminatedChefDoc.data().image;};}};res.json(updatedChallenge);} catch (error) {console.error('Error updating challenge:', error);res.status(error.status || 500);throw new Error(error.message || 'Failed to update challenge');};});export const getCurrentChallenges = asyncHandler(async (req, res) => {const { season } = req.query;if (!season) {res.status(400);throw new Error('Season parameter is required');};try {const latestChallengeQuery = db.collection('challenges');.where('season', '==', parseInt(season));.orderBy('airDate', 'desc');.limit(1);const latestChallengeSnapshot = await latestChallengeQuery.get();if (latestChallengeSnapshot.empty) {res.status(404);throw new Error('No challenges found for this season');};const latestChallenge = {_id: latestChallengeSnapshot.docs[0].id,;...latestChallengeSnapshot.docs[0].data();};const currentChallengesQuery = db.collection('challenges');.where('season', '==', parseInt(season));.where('week', '==', latestChallenge.week);const currentChallengesSnapshot = await currentChallengesQuery.get();const currentChallenges = [];currentChallengesSnapshot.forEach(doc => {currentChallenges.push({_id: doc.id,;...doc.data();});});currentChallenges.sort((a, b) => {if (a.isQuickfire !== b.isQuickfire) {return a.isQuickfire ? -1 : 1;};return new Date(a.airDate) - new Date(b.airDate);});for (const challenge of currentChallenges) {if (challenge.winner) {const winnerDoc = await db.collection('chefs').doc(challenge.winner).get();if (winnerDoc.exists) {challenge.winner = {_id: winnerDoc.id,;name: winnerDoc.data().name,;image: winnerDoc.data().image;};}};if (challenge.topChefs && challenge.topChefs.length > 0) {const topChefDocs = await Promise.all(;challenge.topChefs.map(chefId => db.collection('chefs').doc(chefId).get()););challenge.topChefs = topChefDocs;.filter(doc => doc.exists);.map(doc => ({_id: doc.id,;name: doc.data().name,;image: doc.data().image;}));};if (challenge.bottomChefs && challenge.bottomChefs.length > 0) {const bottomChefDocs = await Promise.all(;challenge.bottomChefs.map(chefId => db.collection('chefs').doc(chefId).get()););challenge.bottomChefs = bottomChefDocs;.filter(doc => doc.exists);.map(doc => ({_id: doc.id,;name: doc.data().name,;image: doc.data().image;}));};if (challenge.eliminatedChef) {const eliminatedChefDoc = await db.collection('chefs').doc(challenge.eliminatedChef).get();if (eliminatedChefDoc.exists) {challenge.eliminatedChef = {_id: eliminatedChefDoc.id,;name: eliminatedChefDoc.data().name,;image: eliminatedChefDoc.data().image;};}}};res.json(currentChallenges);} catch (error) {console.error('Error fetching current challenges:', error);res.status(error.status || 500);throw new Error(error.message || 'Failed to fetch current challenges');};})
--- server/src/controllers/chefController.js ---
import admin, { db } from '../config/firebase.js';import { createLogger, format, transports } from 'winston';import asyncHandler from '../utils/asyncHandler.js';const logger = createLogger({level: process.env.NODE_ENV === 'development' ? 'debug' : 'info',;format: format.combine(;format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),;format.errors({ stack: true }),;format.json();),;transports: [;new transports.Console(),;new transports.File({ filename: 'logs/error.log', level: 'error' }),;new transports.File({ filename: 'logs/combined.log' }),;],;});export const getChefs = asyncHandler(async (req, res) => {try {const chefsSnapshot = await db.collection('chefs');.orderBy('stats.totalPoints', 'desc');.get();const chefs = chefsSnapshot.docs.map((doc) => ({_id: doc.id,;...doc.data(),;}));res.json(chefs);} catch (error) {logger.error('Error fetching chefs:', { message: error.message, stack: error.stack });throw new Error('Failed to fetch chefs');};});export const getChefById = asyncHandler(async (req, res) => {try {const chefDoc = await db.collection('chefs').doc(req.params.id).get();if (!chefDoc.exists) {throw new Error('Chef not found');};const chefData = chefDoc.data() ?? {};res.json({_id: chefDoc.id,;name: chefData.name ?? '',;bio: chefData.bio ?? '',;hometown: chefData.hometown ?? '',;specialty: chefData.specialty ?? '',;image: chefData.image ?? '',;status: chefData.status ?? 'active',;eliminationWeek: chefData.eliminationWeek ?? null,;stats: chefData.stats ?? { wins: 0, eliminations: 0, quickfireWins: 0, challengeWins: 0, totalPoints: 0 },;weeklyPerformance: chefData.weeklyPerformance ?? [],;});} catch (error) {logger.error('Error fetching chef:', { message: error.message, stack: error.stack });throw new Error(error.message || 'Failed to fetch chef');};});export const getChefStats = asyncHandler(async (req, res) => {try {const chefDoc = await db.collection('chefs').doc(req.params.id).get();if (!chefDoc.exists) {throw new Error('Chef not found');};const chefData = chefDoc.data() ?? {};const stats = chefData.stats ?? { wins: 0, eliminations: 0, quickfireWins: 0, challengeWins: 0, totalPoints: 0 };res.json({_id: chefDoc.id,;name: chefData.name ?? '',;stats,;weeklyPerformance: chefData.weeklyPerformance ?? [],;});} catch (error) {logger.error('Error fetching chef stats:', { message: error.message, stack: error.stack });throw new Error(error.message || 'Failed to fetch chef stats');};});export const createChef = asyncHandler(async (req, res) => {const { name, bio, hometown, specialty, image } = req.body;if (!name || !hometown || !specialty) {throw new Error('Name, hometown, and specialty are required');};try {const chef = {name,;bio: bio ?? '',;hometown,;specialty,;image: image ?? '',;status: 'active',;eliminationWeek: null,;stats: {wins: 0,;eliminations: 0,;quickfireWins: 0,;challengeWins: 0,;totalPoints: 0,;},;weeklyPerformance: [],;createdAt: admin.firestore.FieldValue.serverTimestamp(),;};const docRef = await db.collection('chefs').add(chef);const newChef = await docRef.get();const newChefData = newChef.data() ?? {};res.status(201).json({_id: newChef.id,;name: newChefData.name ?? '',;bio: newChefData.bio ?? '',;hometown: newChefData.hometown ?? '',;specialty: newChefData.specialty ?? '',;image: newChefData.image ?? '',;status: newChefData.status ?? 'active',;eliminationWeek: newChefData.eliminationWeek ?? null,;stats: newChefData.stats ?? { wins: 0, eliminations: 0, quickfireWins: 0, challengeWins: 0, totalPoints: 0 },;weeklyPerformance: newChefData.weeklyPerformance ?? [],;});} catch (error) {logger.error('Error creating chef:', { message: error.message, stack: error.stack });throw new Error('Failed to create chef');};});export const updateChef = asyncHandler(async (req, res) => {try {const chefRef = db.collection('chefs').doc(req.params.id);const chefDoc = await chefRef.get();if (!chefDoc.exists) {throw new Error('Chef not found');};const updates = {};if (req.body.name) updates.name = req.body.name;if (req.body.bio) updates.bio = req.body.bio;if (req.body.hometown) updates.hometown = req.body.hometown;if (req.body.specialty) updates.specialty = req.body.specialty;if (req.body.image) updates.image = req.body.image;if (req.body.status) updates.status = req.body.status;if (req.body.eliminationWeek !== undefined) updates.eliminationWeek = req.body.eliminationWeek;if (req.body.stats) {const currentStats = chefDoc.data()?.stats ?? {};updates.stats = { ...currentStats, ...req.body.stats };};if (req.body.weeklyPerformance) {updates.weeklyPerformance = admin.firestore.FieldValue.arrayUnion(req.body.weeklyPerformance);};await chefRef.update(updates);const updatedChef = await chefRef.get();const updatedChefData = updatedChef.data() ?? {};res.json({_id: updatedChef.id,;name: updatedChefData.name ?? '',;bio: updatedChefData.bio ?? '',;hometown: updatedChefData.hometown ?? '',;specialty: updatedChefData.specialty ?? '',;image: updatedChefData.image ?? '',;status: updatedChefData.status ?? 'active',;eliminationWeek: updatedChefData.eliminationWeek ?? null,;stats: updatedChefData.stats ?? { wins: 0, eliminations: 0, quickfireWins: 0, challengeWins: 0, totalPoints: 0 },;weeklyPerformance: updatedChefData.weeklyPerformance ?? [],;});} catch (error) {logger.error('Error updating chef:', { message: error.message, stack: error.stack });throw new Error(error.message || 'Failed to update chef');};});export const updateWeeklyPerformance = asyncHandler(async (req, res) => {const { week, points, performanceNotes } = req.body;if (!week || points === undefined) {throw new Error('Week and points are required');};try {const chefRef = db.collection('chefs').doc(req.params.id);const chefDoc = await chefRef.get();if (!chefDoc.exists) {throw new Error('Chef not found');};const chefData = chefDoc.data() ?? {};const currentStats = chefData.stats ?? { wins: 0, eliminations: 0, quickfireWins: 0, challengeWins: 0, totalPoints: 0 };const newPerformance = {week,;points,;notes: performanceNotes ?? '',;timestamp: admin.firestore.FieldValue.serverTimestamp(),;};await chefRef.update({weeklyPerformance: admin.firestore.FieldValue.arrayUnion(newPerformance),;'stats.totalPoints': currentStats.totalPoints + points,;});const updatedChef = await chefRef.get();const updatedChefData = updatedChef.data() ?? {};res.json({_id: updatedChef.id,;name: updatedChefData.name ?? '',;bio: updatedChefData.bio ?? '',;hometown: updatedChefData.hometown ?? '',;specialty: updatedChefData.specialty ?? '',;image: updatedChefData.image ?? '',;status: updatedChefData.status ?? 'active',;eliminationWeek: updatedChefData.eliminationWeek ?? null,;stats: updatedChefData.stats ?? { wins: 0, eliminations: 0, quickfireWins: 0, challengeWins: 0, totalPoints: 0 },;weeklyPerformance: updatedChefData.weeklyPerformance ?? [],;});} catch (error) {logger.error('Error updating weekly performance:', { message: error.message, stack: error.stack });throw new Error(error.message || 'Failed to update weekly performance');};})
--- server/src/controllers/leagueController.js ---
import { db } from '../config/firebase.js';import asyncHandler from '../utils/asyncHandler.js';import crypto from 'crypto';export const createLeague = asyncHandler(async (req, res) => {const { name, season, maxMembers, maxRosterSize, scoringSettings } = req.body;if (!name || !season) {res.status(400);throw new Error('Name and season are required');};try {const inviteCode = crypto.randomBytes(4).toString('hex').toUpperCase();const leagueRef = db.collection('leagues').doc();const userId = req.user._id;const leagueData = {name,;creator: userId,;season,;maxMembers: maxMembers || 10,;maxRosterSize: maxRosterSize || 5,;inviteCode,;scoringSettings: scoringSettings || {quickfireWin: 10,;challengeWin: 20,;topThree: 5,;bottomThree: -5,;elimination: -15,;finalWinner: 50;},;members: [{user: userId,;role: 'owner',;score: 0,;joinedAt: new Date().toISOString();}],;status: 'draft',;currentWeek: 1,;createdAt: new Date().toISOString();};await leagueRef.set(leagueData);const userRef = db.collection('users').doc(userId);await userRef.update({leagues: firebase.firestore.FieldValue.arrayUnion(leagueRef.id);});const league = {_id: leagueRef.id,;...leagueData;};res.status(201).json(league);if (typeof req.app.get('emitLeagueUpdate') === 'function') {req.app.get('emitLeagueUpdate')(leagueRef.id, { members: league.members });};} catch (error) {console.error('Create league error:', error);res.status(500);throw new Error('Failed to create league');};});export const getUserLeagues = asyncHandler(async (req, res) => {try {const userId = req.user._id;const leaguesSnapshot = await db.collection('leagues');.where('members', 'array-contains', { user: userId });.get();if (leaguesSnapshot.empty) {return res.json([]);};const leagues = [];leaguesSnapshot.forEach(doc => {leagues.push({_id: doc.id,;...doc.data();});});const populatedLeagues = await Promise.all(leagues.map(async (league) => {const creatorDoc = await db.collection('users').doc(league.creator).get();const creator = creatorDoc.exists ? { _id: creatorDoc.id, ...creatorDoc.data() } : null;const memberPromises = league.members.map(async (member) => {const userDoc = await db.collection('users').doc(member.user).get();return {...member,;user: userDoc.exists ? { _id: userDoc.id, ...userDoc.data() } : null;};});const populatedMembers = await Promise.all(memberPromises);return {...league,;creator: creator ? { name: creator.name, email: creator.email } : null,;members: populatedMembers;};}));res.json(populatedLeagues);} catch (error) {console.error('Get user leagues error:', error);res.status(500);throw new Error('Failed to fetch leagues');};});export const getLeagueById = asyncHandler(async (req, res) => {try {const leagueDoc = await db.collection('leagues').doc(req.params.id).get();if (!leagueDoc.exists) {res.status(404);throw new Error('League not found');};const league = {_id: leagueDoc.id,;...leagueDoc.data();};const isMember = league.members.some(m => m.user === req.user._id);if (!isMember) {res.status(403);throw new Error('Not authorized to access this league');};const creatorDoc = await db.collection('users').doc(league.creator).get();league.creator = creatorDoc.exists ?;{ _id: creatorDoc.id, name: creatorDoc.data().name, email: creatorDoc.data().email } : null;const memberPromises = league.members.map(async (member) => {const userDoc = await db.collection('users').doc(member.user).get();return {...member,;user: userDoc.exists ?;{ _id: userDoc.id, name: userDoc.data().name, email: userDoc.data().email } : null;};});league.members = await Promise.all(memberPromises);for (const member of league.members) {if (member.roster && member.roster.length > 0) {const chefPromises = member.roster.map(async (rosterItem) => {const chefDoc = await db.collection('chefs').doc(rosterItem.chef).get();return {...rosterItem,;chef: chefDoc.exists ? { _id: chefDoc.id, ...chefDoc.data() } : null;};});member.roster = await Promise.all(chefPromises);}};res.json(league);} catch (error) {console.error('Get league by id error:', error);res.status(error.status || 500);throw new Error(error.message || 'Failed to fetch league');};});export const updateLeague = asyncHandler(async (req, res) => {try {const leagueRef = db.collection('leagues').doc(req.params.id);const leagueDoc = await leagueRef.get();if (!leagueDoc.exists) {res.status(404);throw new Error('League not found');};const league = {_id: leagueDoc.id,;...leagueDoc.data();};const member = league.members.find(m => m.user === req.user._id);if (!member || (member.role !== 'owner' && member.role !== 'admin')) {res.status(403);throw new Error('Not authorized to update this league');};const updates = {};if (req.body.name) updates.name = req.body.name;if (req.body.maxMembers) updates.maxMembers = req.body.maxMembers;if (req.body.maxRosterSize) updates.maxRosterSize = req.body.maxRosterSize;if (req.body.scoringSettings) updates.scoringSettings = req.body.scoringSettings;if (req.body.status) updates.status = req.body.status;if (req.body.currentWeek) updates.currentWeek = req.body.currentWeek;await leagueRef.update(updates);const updatedLeagueDoc = await leagueRef.get();const updatedLeague = {_id: updatedLeagueDoc.id,;...updatedLeagueDoc.data();};res.json(updatedLeague);if (typeof req.app.get('emitLeagueUpdate') === 'function') {req.app.get('emitLeagueUpdate')(req.params.id, updates);};} catch (error) {console.error('Update league error:', error);res.status(error.status || 500);throw new Error(error.message || 'Failed to update league');};});export const joinLeague = asyncHandler(async (req, res) => {const { inviteCode } = req.body;if (!inviteCode) {res.status(400);throw new Error('Invite code is required');};try {const leaguesSnapshot = await db.collection('leagues');.where('inviteCode', '==', inviteCode);.limit(1);.get();if (leaguesSnapshot.empty) {res.status(404);throw new Error('League not found with that invite code');};const leagueDoc = leaguesSnapshot.docs[0];const league = {_id: leagueDoc.id,;...leagueDoc.data();};if (league.members.length >= league.maxMembers) {res.status(400);throw new Error('League is full');};const userId = req.user._id;const isMember = league.members.some(m => m.user === userId);if (isMember) {res.status(400);throw new Error('You are already a member of this league');};const newMember = {user: userId,;role: 'member',;score: 0,;joinedAt: new Date().toISOString();};await leagueDoc.ref.update({members: firebase.firestore.FieldValue.arrayUnion(newMember);});await db.collection('users').doc(userId).update({leagues: firebase.firestore.FieldValue.arrayUnion(leagueDoc.id);});const updatedLeagueDoc = await leagueDoc.ref.get();const updatedLeague = {_id: updatedLeagueDoc.id,;...updatedLeagueDoc.data();};res.json(updatedLeague);if (typeof req.app.get('emitLeagueUpdate') === 'function') {req.app.get('emitLeagueUpdate')(leagueDoc.id, {members: updatedLeague.members;});};} catch (error) {console.error('Join league error:', error);res.status(error.status || 500);throw new Error(error.message || 'Failed to join league');};});export const updateDraftOrder = asyncHandler(async (req, res) => {const { draftOrder } = req.body;try {const leagueRef = db.collection('leagues').doc(req.params.id);const leagueDoc = await leagueRef.get();if (!leagueDoc.exists) {res.status(404);throw new Error('League not found');};const league = leagueDoc.data();const member = league.members.find(m => m.user === req.user._id);if (!member || (member.role !== 'owner' && member.role !== 'admin')) {res.status(403);throw new Error('Not authorized to update draft order');};await leagueRef.update({ draftOrder });const updatedLeagueDoc = await leagueRef.get();const updatedLeague = {_id: updatedLeagueDoc.id,;...updatedLeagueDoc.data();};res.json(updatedLeague);if (typeof req.app.get('emitLeagueUpdate') === 'function') {req.app.get('emitLeagueUpdate')(req.params.id, { draftOrder });};} catch (error) {console.error('Update draft order error:', error);res.status(error.status || 500);throw new Error(error.message || 'Failed to update draft order');};});export const draftChef = asyncHandler(async (req, res) => {const { chefId } = req.body;if (!chefId) {res.status(400);throw new Error('Chef ID is required');};try {const leagueRef = db.collection('leagues').doc(req.params.id);const leagueDoc = await leagueRef.get();if (!leagueDoc.exists) {res.status(404);throw new Error('League not found');};const league = {_id: leagueDoc.id,;...leagueDoc.data();};if (league.status !== 'draft') {res.status(400);throw new Error('League is not in draft mode');};const userId = req.user._id;const memberIndex = league.members.findIndex(m => m.user === userId);if (memberIndex === -1) {res.status(403);throw new Error('You are not a member of this league');};const member = league.members[memberIndex];if (member.roster && member.roster.length >= league.maxRosterSize) {res.status(400);throw new Error('Your roster is full');};const chefDrafted = league.members.some(m =>;m.roster && m.roster.some(r => r.chef === chefId););if (chefDrafted) {res.status(400);throw new Error('This chef has already been drafted');};const newRoster = [...(member.roster || []), {chef: chefId,;drafted: new Date().toISOString(),;active: true;}];league.members[memberIndex].roster = newRoster;await leagueRef.update({members: league.members;});const updatedLeagueDoc = await leagueRef.get();const updatedLeague = {_id: updatedLeagueDoc.id,;...updatedLeagueDoc.data();};res.json(updatedLeague);if (typeof req.app.get('emitLeagueUpdate') === 'function') {req.app.get('emitLeagueUpdate')(req.params.id, {members: updatedLeague.members;});};} catch (error) {console.error('Draft chef error:', error);res.status(error.status || 500);throw new Error(error.message || 'Failed to draft chef');};});export const getLeagueLeaderboard = asyncHandler(async (req, res) => {try {const leagueRef = db.collection('leagues').doc(req.params.id);const leagueDoc = await leagueRef.get();if (!leagueDoc.exists) {res.status(404);throw new Error('League not found');};const league = {_id: leagueDoc.id,;...leagueDoc.data();};const isMember = league.members.some(m => m.user === req.user._id);if (!isMember) {res.status(403);throw new Error('Not authorized to access this league');};const memberPromises = league.members.map(async (member) => {const userDoc = await db.collection('users').doc(member.user).get();const userData = userDoc.exists ? userDoc.data() : null;return {user: {_id: member.user,;name: userData?.name || 'Unknown',;email: userData?.email || '',;avatar: userData?.avatar || '',;},;score: member.score || 0,;rosterCount: (member.roster?.length || 0);};});const leaderboard = await Promise.all(memberPromises);leaderboard.sort((a, b) => b.score - a.score);res.json(leaderboard);} catch (error) {console.error('Get leaderboard error:', error);res.status(error.status || 500);throw new Error(error.message || 'Failed to fetch leaderboard');};})
--- server/src/controllers/messageController.js ---
import { db } from '../config/firebase.js';import asyncHandler from '../utils/asyncHandler.js';export const getLeagueMessages = asyncHandler(async (req, res) => {try {const { leagueId } = req.params;const { limit = 50, before } = req.query;const leagueDoc = await db.collection('leagues').doc(leagueId).get();if (!leagueDoc.exists) {res.status(404);throw new Error('League not found');};const league = leagueDoc.data();const isMember = league.members.some(member =>;member.user === req.user._id;);if (!isMember) {res.status(403);throw new Error('Not authorized to access this league');};let messagesQuery = db.collection('messages');.where('league', '==', leagueId);.orderBy('createdAt', 'desc');.limit(parseInt(limit));if (before) {const beforeDate = new Date(before);messagesQuery = messagesQuery.where('createdAt', '<', beforeDate);};const messagesSnapshot = await messagesQuery.get();const messages = [];const userPromises = [];messagesSnapshot.forEach(doc => {messages.push({_id: doc.id,;...doc.data();});});for (const message of messages) {const senderDoc = await db.collection('users').doc(message.sender).get();if (senderDoc.exists) {message.sender = {_id: senderDoc.id,;name: senderDoc.data().name,;email: senderDoc.data().email,;avatar: senderDoc.data().avatar || '';};}};const batch = db.batch();for (const message of messages) {if (!message.readBy.includes(req.user._id)) {const messageRef = db.collection('messages').doc(message._id);batch.update(messageRef, {readBy: [...message.readBy, req.user._id];});}};await batch.commit();res.json(messages);} catch (error) {console.error('Get league messages error:', error);res.status(error.status || 500);throw new Error(error.message || 'Failed to fetch messages');};});export const createMessage = asyncHandler(async (req, res) => {const { leagueId, content, type = 'text' } = req.body;try {const leagueDoc = await db.collection('leagues').doc(leagueId).get();if (!leagueDoc.exists) {res.status(404);throw new Error('League not found');};const league = leagueDoc.data();const isMember = league.members.some(member =>;member.user === req.user._id;);if (!isMember) {res.status(403);throw new Error('Not authorized to post in this league');};const message = {league: leagueId,;sender: req.user._id,;content,;type,;reactions: {likes: [],;hearts: [];},;readBy: [req.user._id],  // Sender has read the message by default;createdAt: new Date().toISOString();};const messageRef = await db.collection('messages').add(message);const messageDoc = await messageRef.get();const senderDoc = await db.collection('users').doc(req.user._id).get();const completeMessage = {_id: messageRef.id,;...messageDoc.data(),;sender: {_id: senderDoc.id,;name: senderDoc.data().name,;email: senderDoc.data().email,;avatar: senderDoc.data().avatar || ''};};res.status(201).json(completeMessage);} catch (error) {console.error('Create message error:', error);res.status(error.status || 500);throw new Error(error.message || 'Failed to create message');};});export const addReaction = asyncHandler(async (req, res) => {const { reaction } = req.body;if (!['likes', 'hearts'].includes(reaction)) {res.status(400);throw new Error('Invalid reaction type');};try {const messageRef = db.collection('messages').doc(req.params.id);const messageDoc = await messageRef.get();if (!messageDoc.exists) {res.status(404);throw new Error('Message not found');};const message = messageDoc.data();const hasReacted = message.reactions[reaction].includes(req.user._id);if (hasReacted) {await messageRef.update({[`reactions.${reaction}`]: message.reactions[reaction].filter(;userId => userId !== req.user._id;);});} else {await messageRef.update({[`reactions.${reaction}`]: [...message.reactions[reaction], req.user._id];});};const updatedDoc = await messageRef.get();res.json({message: 'Reaction updated',;reactions: updatedDoc.data().reactions;});} catch (error) {console.error('Add reaction error:', error);res.status(error.status || 500);throw new Error(error.message || 'Failed to update reaction');};});export const getUnreadCount = asyncHandler(async (req, res) => {const { leagueId } = req.params;try {const leagueDoc = await db.collection('leagues').doc(leagueId).get();if (!leagueDoc.exists) {res.status(404);throw new Error('League not found');};const league = leagueDoc.data();const isMember = league.members.some(member =>;member.user === req.user._id;);if (!isMember) {res.status(403);throw new Error('Not authorized to access this league');};const unreadQuery = db.collection('messages');.where('league', '==', leagueId);.where('sender', '!=', req.user._id);.where('readBy', 'array-contains-any', [req.user._id]);const unreadSnapshot = await unreadQuery.get();const totalQuery = db.collection('messages');.where('league', '==', leagueId);.where('sender', '!=', req.user._id);const totalSnapshot = await totalQuery.get();const unreadCount = totalSnapshot.size - unreadSnapshot.size;res.json({ unreadCount });} catch (error) {console.error('Get unread count error:', error);res.status(error.status || 500);throw new Error(error.message || 'Failed to get unread count');};})
--- server/src/index.js ---
import firebaseAdmin, { db, auth } from './config/firebase.js';import express from 'express';import http from 'http';import { Server } from 'socket.io';import dotenv from 'dotenv';import cors from 'cors';import helmet from 'helmet';import morgan from 'morgan';import portfinder from 'portfinder';import { createLogger, format, transports } from 'winston';import setupSocket from './socket/index.js';import fs from 'fs';import path from 'path';import { fileURLToPath } from 'url';const __filename = fileURLToPath(import.meta.url);const __dirname = path.dirname(__filename);dotenv.config();const logger = createLogger({level: process.env.NODE_ENV === 'development' ? 'debug' : 'info',;format: format.combine(;format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),;format.errors({ stack: true }),;format.json();),;transports: [;new transports.Console(),;new transports.File({ filename: 'logs/error.log', level: 'error' }),;new transports.File({ filename: 'logs/combined.log' }),;],;});const gracefulShutdown = (server, io, signal) => {logger.info(`Received ${signal}. Starting graceful shutdown...`);io.close(() => {logger.info('Socket.IO connections closed.');server.close(() => {logger.info('HTTP server closed.');process.exit(0);});});};const startServer = async () => {try {const app = express();const server = http.createServer(app);const io = new Server(server, {cors: {origin: process.env.CLIENT_URL || 'http://localhost:5173',;methods: ['GET', 'POST', 'PUT', 'DELETE'],;credentials: true,;},;pingTimeout: 60000,;pingInterval: 25000,;});setupSocket(io);app.use(express.json({ limit: '10mb' }));app.use(express.urlencoded({ extended: true }));app.use(cors({origin: process.env.CLIENT_URL || 'http://localhost:5173',;methods: ['GET', 'POST', 'PUT', 'DELETE'],;credentials: true,;}));app.use(helmet({contentSecurityPolicy: {directives: {defaultSrc: ["'self'"],;scriptSrc: ["'self'", "'unsafe-inline'"],;},;},;}));app.use(morgan('dev', {stream: { write: (message) => logger.info(message.trim()) },;}));app.get('/health', async (req, res) => {try {await db.collection('health').doc('status').set({lastChecked: firebaseAdmin.firestore.FieldValue.serverTimestamp();});res.status(200).json({status: 'healthy',;uptime: process.uptime(),;timestamp: new Date().toISOString(),;});} catch (error) {logger.error('Health check failed:', error);res.status(500).json({ status: 'unhealthy', error: error.message });};});const routeNames = [;'authRoutes',;'chefRoutes',;'leagueRoutes',;'challengeRoutes',;'messageRoutes';];for (const routeName of routeNames) {const route = await import(`./routes/${routeName}.js`);app.use(`/api/${routeName.replace('Routes', '')}`, route.default);};app.get('/', (req, res) => {res.send('Top Chef Fantasy API is running...');});app.use((req, res, next) => {const error = new Error(`Not Found - ${req.originalUrl}`);res.status(404);next(error);});app.use((err, req, res, next) => {logger.error(`Server Error: ${err.message}`, { stack: err.stack });const statusCode = res.statusCode === 200 ? 500 : res.statusCode;res.status(statusCode).json({message: err.message,;stack: process.env.NODE_ENV === 'development' ? err.stack : undefined,;});});const basePort = parseInt(process.env.PORT, 10) || 5000;portfinder.basePort = basePort;const port = await portfinder.getPortPromise();server.listen(port, () => {logger.info(`Server running on port ${port} in ${process.env.NODE_ENV || 'development'} mode`);const portFilePath = path.resolve(__dirname, '../../client/backend-port.json');try {fs.writeFileSync(portFilePath, JSON.stringify({ port }), 'utf8');logger.info(`Port ${port} saved to ${portFilePath}`);} catch (writeError) {logger.error(`Failed to write port file: ${writeError.message}`, { stack: writeError.stack });};});['SIGINT', 'SIGTERM'].forEach((signal) => {process.on(signal, () => gracefulShutdown(server, io, signal));});process.on('unhandledRejection', (reason, promise) => {logger.error('Unhandled Rejection at:', promise, 'reason:', reason);gracefulShutdown(server, io, 'unhandledRejection');});process.on('uncaughtException', (err) => {logger.error('Uncaught Exception:', err);gracefulShutdown(server, io, 'uncaughtException');});} catch (err) {logger.error('Failed to start server:', err);process.exit(1);};};startServer()
--- server/src/middleware/authMiddleware.js ---
import { auth, db } from '../config/firebase.js';import asyncHandler from '../utils/asyncHandler.js';export const protect = asyncHandler(async (req, res, next) => {let token;if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {try {token = req.headers.authorization.split(' ')[1];console.log('Token received:', token.substring(0, 20) + '...');const decodedToken = await auth.verifyIdToken(token);console.log('Token verified for user:', decodedToken.uid);req.user = {_id: decodedToken.uid,;email: decodedToken.email || decodedToken.firebase.identities.email?.[0];};next();} catch (error) {console.error('Auth middleware error:', error);res.status(401);throw new Error('Not authorized, token failed');};} else {console.log('No token found in request headers');res.status(401);throw new Error('Not authorized, no token');};});export const admin = asyncHandler(async (req, res, next) => {try {const userDoc = await db.collection('users').doc(req.user._id).get();if (userDoc.exists && userDoc.data()?.isAdmin) {next();} else {res.status(403);throw new Error('Not authorized as an admin');};} catch (error) {console.error('Admin middleware error:', error);res.status(403);throw new Error('Not authorized as an admin');};})
--- server/src/middleware/errorMiddleware.js ---
export const notFound = (req, res, next) => {const error = new Error(`Not Found - ${req.originalUrl}`);res.status(404);next(error);};export const errorHandler = (err, req, res, next) => {const statusCode = res.statusCode === 200 ? 500 : res.statusCode;res.status(statusCode);res.json({message: err.message,;stack: process.env.NODE_ENV === 'production' ? null : err.stack,;});}
--- server/src/models/challengeModel.js ---
import mongoose from 'mongoose';const challengeSchema = new mongoose.Schema({season: { type: Number, required: [true, 'Please provide a season number'] }, // Comma added here;week: { type: Number, required: [true, 'Please provide a week number'] },;title: { type: String, required: [true, 'Please provide a challenge title'] },;description: { type: String, required: [true, 'Please provide a challenge description'] },;location: { type: String, required: [true, 'Please provide a location'] },;isQuickfire: { type: Boolean, default: false },;guest: { type: String, default: '' },;winner: { type: mongoose.Schema.Types.ObjectId, ref: 'Chef', default: null },;topChefs: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Chef' }],;bottomChefs: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Chef' }],;eliminatedChef: { type: mongoose.Schema.Types.ObjectId, ref: 'Chef', default: null },;airDate: { type: Date, required: [true, 'Please provide an air date'] },;status: { type: String, enum: ['upcoming', 'completed'], default: 'upcoming' };}, {timestamps: true;});const Challenge = mongoose.model('Challenge', challengeSchema);export default Challenge
--- server/src/models/chefModel.js ---
import mongoose from 'mongoose';const chefSchema = new mongoose.Schema({name: { type: String, required: [true, 'Please provide a chef name'], trim: true },;bio: { type: String, required: [true, 'Please provide a chef bio'] },;hometown: { type: String, required: [true, 'Please provide a hometown'] },;specialty: { type: String, required: [true, 'Please provide a specialty'] },;image: { type: String, default: '' },;status: { type: String, enum: ['active', 'eliminated', 'winner'], default: 'active' },;eliminationWeek: { type: Number, default: null },;stats: {wins: { type: Number, default: 0 },;eliminations: { type: Number, default: 0 },;quickfireWins: { type: Number, default: 0 },;challengeWins: { type: Number, default: 0 },;totalPoints: { type: Number, default: 0 };},;weeklyPerformance: [{week: Number,;points: Number,;rank: Number,;highlights: String;}];}, {timestamps: true;});const Chef = mongoose.models.Chef || mongoose.model('Chef', chefSchema);export default Chef
--- server/src/models/FirestoreSchema.js ---
export {}
--- server/src/models/leagueModel.js ---
import mongoose from 'mongoose';const leagueSchema = new mongoose.Schema({name: { type: String, required: [true, 'Please provide a league name'], trim: true },;creator: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },;members: [{user: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },;role: { type: String, enum: ['owner', 'admin', 'member'], default: 'member' },;roster: [{chef: { type: mongoose.Schema.Types.ObjectId, ref: 'Chef' },;drafted: { type: Date, default: Date.now },;active: { type: Boolean, default: true };}],;score: { type: Number, default: 0 };}],;season: { type: Number, required: [true, 'Please provide a season number'] },;maxMembers: { type: Number, default: 10 },;maxRosterSize: { type: Number, default: 5 },;status: { type: String, enum: ['draft', 'active', 'completed'], default: 'draft' },;inviteCode: { type: String, required: true, unique: true },;scoringSettings: {quickfireWin: { type: Number, default: 10 },;challengeWin: { type: Number, default: 20 },;topThree: { type: Number, default: 5 },;bottomThree: { type: Number, default: -5 },;elimination: { type: Number, default: -15 },;finalWinner: { type: Number, default: 50 };},;draftOrder: [{user: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },;position: Number;}],;currentWeek: { type: Number, default: 1 };}, {timestamps: true;});const League = mongoose.models.League || mongoose.model('League', leagueSchema);export default League
--- server/src/models/messageModel.js ---
import mongoose from 'mongoose';const messageSchema = new mongoose.Schema({league: { type: mongoose.Schema.Types.ObjectId, ref: 'League', required: true },;sender: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },;content: { type: String, required: [true, 'Please provide message content'] },;type: { type: String, enum: ['text', 'image', 'system'], default: 'text' },;reactions: {likes: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }],;hearts: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }];},;readBy: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }];}, {timestamps: true;});const Message = mongoose.models.Message || mongoose.model('Message', messageSchema);export default Message
--- server/src/models/userModel.js ---
import mongoose from 'mongoose';import bcrypt from 'bcryptjs';const userSchema = new mongoose.Schema({name: { type: String, required: [true, 'Please provide a name'], trim: true },;email: { type: String, required: [true, 'Please provide an email'], unique: true, lowercase: true, match: [/^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/, 'Please provide a valid email'] },;password: { type: String, required: [true, 'Please provide a password'], minlength: [6, 'Password must be at least 6 characters'], select: false },;avatar: { type: String, default: '' },;isAdmin: { type: Boolean, default: false },;leagues: [{ type: mongoose.Schema.Types.ObjectId, ref: 'League' }],;createdAt: { type: Date, default: Date.now };}, { timestamps: true });userSchema.pre('save', async function(next) {if (!this.isModified('password')) {next();};const salt = await bcrypt.genSalt(10);this.password = await bcrypt.hash(this.password, salt);});userSchema.methods.matchPassword = async function(enteredPassword) {return await bcrypt.compare(enteredPassword, this.password);};const User = mongoose.models.User || mongoose.model('User', userSchema);export default User
--- server/src/routes/authRoutes.js ---
import express from 'express';import {registerUser,;loginUser,;getUserProfile,;updateUserProfile,;getUsers;} from '../controllers/authController.js';import { protect, admin } from '../middleware/authMiddleware.js';const router = express.Router();router.post('/register', registerUser);router.post('/login', loginUser);router.get('/profile', protect, getUserProfile);router.put('/profile', protect, updateUserProfile);router.get('/users', protect, admin, getUsers);export default router
--- server/src/routes/challengeRoutes.js ---
import express from 'express';import {getChallenges,;getChallengeById,;createChallenge,;updateChallenge,;getCurrentChallenges;} from '../controllers/challengeController.js';import { protect, admin } from '../middleware/authMiddleware.js';const router = express.Router();router.use(protect);router.route('/');.get(getChallenges);.post(admin, createChallenge);router.get('/current', getCurrentChallenges);router.route('/:id');.get(getChallengeById);.put(admin, updateChallenge);export default router
--- server/src/routes/chefRoutes.js ---
import express from 'express';import { getChefs, getChefById, createChef, updateChef, getChefStats, updateWeeklyPerformance } from '../controllers/chefController.js';const router = express.Router();router.get('/', getChefs);router.get('/:id', getChefById);router.post('/', createChef); // Admin only;router.put('/:id', updateChef); // Admin only;router.get('/:id/stats', getChefStats);router.put('/:id/weekly-performance', updateWeeklyPerformance); // Assumed route causing error;export default router
--- server/src/routes/leagueRoutes.js ---
import express from 'express';import {createLeague,;getUserLeagues,;getLeagueById,;updateLeague,;joinLeague,;updateDraftOrder,;draftChef,;getLeagueLeaderboard;} from '../controllers/leagueController.js';import { protect } from '../middleware/authMiddleware.js';const router = express.Router();router.use(protect);router.route('/');.get(getUserLeagues);.post(createLeague);router.post('/join', joinLeague);router.route('/:id');.get(getLeagueById);.put(updateLeague);router.put('/:id/draft-order', updateDraftOrder);router.post('/:id/draft', draftChef);router.get('/:id/leaderboard', getLeagueLeaderboard);export default router
--- server/src/routes/messageRoutes.js ---
import express from 'express';import {getLeagueMessages,;createMessage,;addReaction,;getUnreadCount;} from '../controllers/messageController.js';import { protect } from '../middleware/authMiddleware.js';const router = express.Router();router.use(protect);router.post('/', createMessage);router.get('/:leagueId', getLeagueMessages);router.post('/:id/reaction', addReaction);router.get('/unread/:leagueId', getUnreadCount);export default router
--- server/src/socket/index.js ---
import { verifyToken } from '../utils/tokenUtils.js';export const EVENTS = {CONNECTION: 'connection',;DISCONNECT: 'disconnect',;JOIN_LEAGUE: 'join_league',;LEAVE_LEAGUE: 'leave_league',;SEND_MESSAGE: 'send_message',;CHAT_MESSAGE: 'chat_message',;CHEF_UPDATE: 'chef_update',;LEAGUE_UPDATE: 'league_update',;USER_TYPING: 'user_typing',;USER_JOINED: 'user_joined',;USER_LEFT: 'user_left',;SCORE_UPDATE: 'score_update';};const setupSocket = (io) => {io.use((socket, next) => {try {const token = socket.handshake.auth.token;if (!token) {return next(new Error('Authentication error: No token provided'));};const user = verifyToken(token);if (!user) {return next(new Error('Authentication error: Invalid token'));};socket.user = user;next();} catch (error) {console.error('Socket authentication error:', error.stack); // Detailed logging;next(new Error('Authentication error: Invalid token'));};});io.on(EVENTS.CONNECTION, (socket) => {console.log(`User connected: ${socket.user.id}`);socket.on(EVENTS.JOIN_LEAGUE, ({ leagueId }) => {try {socket.join(`league:${leagueId}`);console.log(`User ${socket.user.id} joined league: ${leagueId}`);socket.to(`league:${leagueId}`).emit(EVENTS.USER_JOINED, {userId: socket.user.id,;username: socket.user.name,;timestamp: new Date();});} catch (error) {console.error('Error in JOIN_LEAGUE:', error.stack);};});socket.on(EVENTS.LEAVE_LEAGUE, ({ leagueId }) => {try {socket.leave(`league:${leagueId}`);console.log(`User ${socket.user.id} left league: ${leagueId}`);socket.to(`league:${leagueId}`).emit(EVENTS.USER_LEFT, {userId: socket.user.id,;username: socket.user.name,;timestamp: new Date();});} catch (error) {console.error('Error in LEAVE_LEAGUE:', error.stack);};});socket.on(EVENTS.SEND_MESSAGE, (message) => {try {const enhancedMessage = {...message,;userId: socket.user.id,;username: socket.user.name,;timestamp: new Date();};io.to(`league:${message.leagueId}`).emit(EVENTS.CHAT_MESSAGE, enhancedMessage);} catch (error) {console.error('Error in SEND_MESSAGE:', error.stack);};});socket.on(EVENTS.USER_TYPING, ({ leagueId }) => {try {socket.to(`league:${leagueId}`).emit(EVENTS.USER_TYPING, {userId: socket.user.id,;username: socket.user.name;});} catch (error) {console.error('Error in USER_TYPING:', error.stack);};});socket.on(EVENTS.DISCONNECT, () => {console.log(`User disconnected: ${socket.user.id}`);});});};export default setupSocket
--- server/src/utils/asyncHandler.js ---
const asyncHandler = (fn) => (req, res, next) => {Promise.resolve(fn(req, res, next)).catch(next);};export default asyncHandler
--- server/src/utils/tokenUtils.js ---
import jwt from 'jsonwebtoken';export const generateToken = (id) => {return jwt.sign({ id }, process.env.JWT_SECRET, {expiresIn: process.env.JWT_EXPIRE || '30d' // Default to 30 days if not set;});};export const verifyToken = (token) => {return jwt.verify(token, process.env.JWT_SECRET);}
--- client/.eslintrc.cjs ---
module.exports = {root: true,;env: { browser: true, es2020: true, node: true },;extends: [;'eslint:recommended',;'plugin:react/recommended',;'plugin:react/jsx-runtime',;'plugin:react-hooks/recommended',;'plugin:@typescript-eslint/recommended' // Added for TypeScript;],;ignorePatterns: ['dist', '.eslintrc.cjs'],;parser: '@typescript-eslint/parser', // Use TS parser for JS/JSX;parserOptions: {ecmaVersion: 'latest',;sourceType: 'module',;project: './tsconfig.json' // Link to your TS config;},;settings: { react: { version: '19.0' } },;plugins: ['react-refresh', '@typescript-eslint'],;rules: {'react-refresh/only-export-components': [;'warn',;{ allowConstantExport: true };],;'react/prop-types': 'off',;'no-unused-vars': 'off', // Turn off base rule;'@typescript-eslint/no-unused-vars': ['warn'], // Use TS version;'no-console': 'off',;'@typescript-eslint/no-explicit-any': 'off' // Relax TS strictness};}
--- client/backend-port.json ---
{"port":5000}
--- client/package.json ---
{"name": "top-chef-fantasy",;"private": true,;"version": "0.1.0",;"type": "module",;"scripts": {"dev": "vite",;"build": "vite build",;"preview": "vite preview",;"lint": "eslint . --ext js,jsx --report-unused-disable-directives --max-warnings 0",;"predev": "node -e \"require('child_process').exec('kill-port 5173 5174', (err) => { if (err) console.log('Ports already free or error:', err); })\"";},;"dependencies": {"@heroicons/react": "^2.1.4",;"axios": "1.8.4",;"axios-retry": "^4.5.0",;"chart.js": "4.4.4",;"date-fns": "4.1.0",;"firebase": "^11.5.0",;"react": "19.0.0",;"react-chartjs-2": "^5.2.0",;"react-dom": "19.0.0",;"react-router-dom": "7.4.0",;"socket.io-client": "^4.7.5";},;"devDependencies": {"@types/react": "19.0.12",;"@types/react-dom": "19.0.4",;"@vitejs/plugin-react": "^4.3.4",;"autoprefixer": "^10.4.21",;"eslint": "^8.56.0",;"eslint-plugin-react": "^7.33.2",;"eslint-plugin-react-hooks": "^4.6.0",;"eslint-plugin-react-refresh": "^0.4.5",;"kill-port": "^2.0.1",;"postcss": "^8.5.3",;"tailwindcss": "^3.4.17",;"vite": "^6.2.3"}}
--- client/postcss.config.cjs ---
module.exports = {plugins: {tailwindcss: {},;autoprefixer: {},;},;}
--- client/src/layouts/AuthLayout.tsx ---
import { Outlet } from 'react-router-dom';import { useTheme } from '../hooks/useTheme';import Logo from '../components/ui/Logo';import ThemeToggle from '../components/ui/ThemeToggle';function AuthLayout() {useTheme(); // Still call the hook to enable theme context;return (;<div className="min-h-screen flex flex-col bg-gray-50 dark:bg-gray-900">;<header className="py-4 px-6 flex justify-between items-center">;<Logo />;<ThemeToggle />;</header>;<main className="flex-grow flex items-center justify-center p-6">;<div className="w-full max-w-md">;<Outlet />;</div>;</main>;<footer className="py-4 px-6 text-center text-sm text-gray-500 dark:text-gray-400">;<p>Top Chef Fantasy League &copy; {new Date().getFullYear()}</p>;</footer>;</div>;);};export default AuthLayout
--- client/src/layouts/MainLayout.tsx ---
import { useState, useCallback } from 'react';import { Outlet } from 'react-router-dom';import Sidebar from '../components/navigation/Sidebar';import Header from '../components/navigation/Header';import ChatPanel from '../components/chat/ChatPanel';import MobileNav from '../components/navigation/MobileNav';function MainLayout() {const [isChatOpen, setIsChatOpen] = useState<boolean>(false);const [isSidebarCollapsed, setIsSidebarCollapsed] = useState<boolean>(false);const toggleChat = useCallback(() => {setIsChatOpen(prev => !prev);}, []);const toggleSidebar = useCallback(() => {setIsSidebarCollapsed(prev => !prev);}, []);return (;<div className="flex h-screen overflow-hidden">;{/* Sidebar - desktop */};<div className={`hidden md:block bg-white dark:bg-gray-800 border-r border-gray-200 dark:border-gray-700 ${isSidebarCollapsed ? 'w-16' : 'w-64';} transition-all duration-200`}>;<Sidebar;collapsed={isSidebarCollapsed};onToggle={toggleSidebar};/>;</div>;{/* Main content */};<div className="flex flex-col flex-1 h-full overflow-hidden">;{/* Header */};<Header toggleChat={toggleChat} isChatOpen={isChatOpen} />;{/* Content area */};<div className="flex flex-1 overflow-hidden">;<main className="flex-1 overflow-y-auto p-4 md:p-6">;<Outlet />;</main>;{/* Chat panel */};{isChatOpen && (;<div className="hidden md:block w-80 bg-white dark:bg-gray-800 border-l border-gray-200 dark:border-gray-700">;<ChatPanel onClose={toggleChat} />;</div>;)};</div>;{/* Mobile navigation */};<MobileNav toggleChat={toggleChat} isChatOpen={isChatOpen} />;</div>;</div>;);};export default MainLayout
--- client/src/pages/Register.tsx ---
import { useState } from 'react';import { Link } from 'react-router-dom';import { useAuth } from '../hooks/useAuth';import { authService } from '../services/authService'; // Fixed to use named export;import Card from '../components/ui/Card';import Input from '../components/ui/Input';import Button from '../components/ui/Button';const Register = () => {const [name, setName] = useState('');const [email, setEmail] = useState('');const [password, setPassword] = useState('');const [confirmPassword, setConfirmPassword] = useState('');const [formError, setFormError] = useState('');const { register, loading, error } = useAuth();const handleSubmit = async (e) => {e.preventDefault();setFormError('');console.log('Form Submitted:', { name, email, password });if (!name || !email || !password || !confirmPassword) {setFormError('Please fill in all fields');console.log('Validation failed: Missing fields');return;};if (password !== confirmPassword) {setFormError('Passwords do not match');console.log('Validation failed: Passwords mismatch');return;};if (password.length < 6) {setFormError('Password must be at least 6 characters');console.log('Validation failed: Password too short');return;};try {console.log('Starting registration...');const userProfile = await authService.register({ name, email, password });console.log('Registered User:', userProfile);const tokenResult = await authService.getToken();console.log('Firebase ID Token:', tokenResult);console.log('Calling useAuth register...');await register({ name, email, password });console.log('Registration complete');} catch (err) {console.error('Registration error:', err.message);setFormError(err.message || 'Failed to register');};};return (;<Card padding="lg" className="animate-fade-in">;<div className="text-center mb-6">;<h1 className="text-2xl font-bold text-gray-900 dark:text-white">Create an Account</h1>;<p className="text-gray-600 dark:text-gray-400">Join the Top Chef Fantasy community</p>;</div>;{(error || formError) && (;<div className="mb-4 p-3 bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-400 rounded-lg">;{error || formError};</div>;)};<form onSubmit={handleSubmit}>;<Input;label="Name";type="text";id="name";placeholder="Enter your name";value={name};onChange={(e) => setName(e.target.value)};required;/>;<Input;label="Email Address";type="email";id="email";placeholder="Enter your email";value={email};onChange={(e) => setEmail(e.target.value)};required;/>;<Input;label="Password";type="password";id="password";placeholder="Create a password";value={password};onChange={(e) => setPassword(e.target.value)};helper="Password must be at least 6 characters";required;/>;<Input;label="Confirm Password";type="password";id="confirmPassword";placeholder="Confirm your password";value={confirmPassword};onChange={(e) => setConfirmPassword(e.target.value)};required;/>;<div className="mb-6">;<div className="flex items-center">;<input;id="terms";type="checkbox";className="h-4 w-4 text-primary-600 focus:ring-primary-500 border-gray-300 rounded";required;/>;<label htmlFor="terms" className="ml-2 block text-sm text-gray-700 dark:text-gray-300">;I agree to the{' '};<a href="#" className="text-primary-600 hover:text-primary-500 dark:text-primary-400">;Terms of Service;</a>{' '};and{' '};<a href="#" className="text-primary-600 hover:text-primary-500 dark:text-primary-400">;Privacy Policy;</a>;</label>;</div>;</div>;<Button;type="submit";variant="primary";fullWidth;isLoading={loading};>;Create Account;</Button>;</form>;<div className="mt-6 text-center">;<p className="text-sm text-gray-600 dark:text-gray-400">;Already have an account?{' '};<Link to="/login" className="text-primary-600 hover:text-primary-500 dark:text-primary-400 font-medium">;Sign in;</Link>;</p>;</div>;</Card>;);};export default Register
--- client/src/pages/Schedule.tsx ---
import React, { useEffect, useState } from 'react';import { useLeague } from '../hooks/useLeague.jsx';import Card from '../components/ui/Card.jsx';const Schedule = () => {const { challenges, currentLeague, loading, error, fetchLeagueDetails } = useLeague();const [selectedChallenge, setSelectedChallenge] = useState(null);useEffect(() => {if (currentLeague?._id) {fetchLeagueDetails(currentLeague._id);};}, [currentLeague?._id, fetchLeagueDetails]);const handleSelectChallenge = (challenge) => {setSelectedChallenge(challenge);};const closeDetails = () => {setSelectedChallenge(null);};if (loading) {return (;<div className="flex justify-center items-center h-full">;<svg className="animate-spin h-10 w-10 text-primary-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">;<circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>;<path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>;</svg>;</div>;);};return (;<div className="space-y-6">;<div className="flex justify-between items-center">;<h1 className="text-2xl font-bold text-gray-900 dark:text-white">Challenge Schedule</h1>;</div>;{error && (;<div className="bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-400 p-4 rounded-lg">;{error};</div>;)};{!currentLeague ? (;<div className="text-center py-12 bg-gray-50 dark:bg-gray-800/50 rounded-xl">;<h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">;No league selected;</h3>;<p className="text-gray-600 dark:text-gray-400">;Please select a league to view challenge schedule.;</p>;</div>;) : challenges && challenges.length > 0 ? (;<div className="space-y-6">;<Card title="Current Week: Week">;<div className="space-y-4">;{challenges;.filter(challenge => challenge.week === currentLeague.currentWeek);.map(challenge => (;<div;key={challenge._id};className="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-600 transition-colors";onClick={() => handleSelectChallenge(challenge)};>;<div className="flex flex-col md:flex-row md:justify-between md:items-center gap-2">;<div>;<div className="flex items-center gap-2">;<h3 className="font-medium">{challenge.title}</h3>;<span className="text-xs px-2 py-0.5 rounded-full">;{challenge.isQuickfire ? 'Quickfire' : 'Elimination'};</span>;</div>;<p className="text-sm text-gray-600 dark:text-gray-400">;{challenge.location} • {new Date(challenge.airDate).toLocaleDateString()};</p>;</div>;<div>;<span className="text-xs px-2 py-0.5 rounded-full">;{challenge.status};</span>;</div>;</div>;</div>;))};</div>;</Card>;<Card title="Season Schedule">;<div className="space-y-6">;{Array.from(new Set(challenges.map(c => c.week))).sort((a, b) => a - b).map(week => (;<div key={week} className="space-y-2">;<h3 className="font-medium text-gray-900 dark:text-white">Week {week}</h3>;<div className="space-y-2 ml-4">;{challenges;.filter(challenge => challenge.week === week);.map(challenge => (;<div;key={challenge._id};className="bg-gray-50 dark:bg-gray-700 p-3 rounded-lg cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-600 transition-colors";onClick={() => handleSelectChallenge(challenge)};>;<div className="flex flex-col md:flex-row md:justify-between md:items-center gap-2">;<div>;<div className="flex items-center gap-2">;<h4 className="font-medium text-sm">{challenge.title}</h4>;<span className="text-xs px-2 py-0.5 rounded-full">;{challenge.isQuickfire ? 'Quickfire' : 'Elimination'};</span>;</div>;<p className="text-xs text-gray-600 dark:text-gray-400">;{challenge.location} • {new Date(challenge.airDate).toLocaleDateString()};</p>;</div>;<div>;<span className="text-xs px-2 py-0.5 rounded-full">;{challenge.status};</span>;</div>;</div>;</div>;))};</div>;</div>;))};</div>;</Card>;</div>;) : (;<div className="text-center py-12 bg-gray-50 dark:bg-gray-800/50 rounded-xl">;<h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">;No challenges available;</h3>;<p className="text-gray-600 dark:text-gray-400">;There are no challenges scheduled for this league yet.;</p>;</div>;)};{selectedChallenge && (;<div className="fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-50">;<div className="bg-white dark:bg-gray-800 rounded-xl w-full max-w-2xl max-h-[90vh] overflow-auto">;<div className="p-6">;<div className="flex justify-between items-start">;<h2 className="text-2xl font-bold text-gray-900 dark:text-white">{selectedChallenge.title}</h2>;<button;onClick={closeDetails};className="p-1 rounded-lg text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 focus:outline-none";>;<svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">;<path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />;</svg>;</button>;</div>;<div className="flex items-center space-x-2 mt-2">;<span className="text-xs px-2 py-0.5 rounded-full">;{selectedChallenge.isQuickfire ? 'Quickfire' : 'Elimination'};</span>;<span className="text-xs px-2 py-0.5 rounded-full">;{selectedChallenge.status};</span>;</div>;<div className="mt-6 space-y-6">;<div>;<h3 className="font-medium text-lg mb-2">Challenge Details</h3>;<div className="grid grid-cols-1 md:grid-cols-2 gap-4">;<div>;<span className="text-sm text-gray-600 dark:text-gray-400">Location</span>;<p className="font-medium">{selectedChallenge.location}</p>;</div>;<div>;<span className="text-sm text-gray-600 dark:text-gray-400">Air Date</span>;<p className="font-medium">{new Date(selectedChallenge.airDate).toLocaleDateString()}</p>;</div>;{selectedChallenge.guest && (;<div>;<span className="text-sm text-gray-600 dark:text-gray-400">Guest Judge</span>;<p className="font-medium">{selectedChallenge.guest}</p>;</div>;)};</div>;</div>;<div>;<h3 className="font-medium text-lg mb-2">Description</h3>;<p className="text-gray-700 dark:text-gray-300">{selectedChallenge.description}</p>;</div>;{selectedChallenge.status === 'completed' && (;<div>;<h3 className="font-medium text-lg mb-2">Results</h3>;{selectedChallenge.winner && (;<div className="mb-4">;<span className="text-sm text-gray-600 dark:text-gray-400">Winner</span>;<p className="font-medium">{selectedChallenge.winner.name}</p>;</div>;)};<div className="grid grid-cols-1 md:grid-cols-2 gap-4">;{selectedChallenge.topChefs && selectedChallenge.topChefs.length > 0 && (;<div>;<span className="text-sm text-gray-600 dark:text-gray-400">Top Performers</span>;<ul className="mt-1 space-y-1">;{selectedChallenge.topChefs.map(chef => (;<li key={chef._id} className="text-gray-700 dark:text-gray-300">;{chef.name};</li>;))};</ul>;</div>;)};{selectedChallenge.bottomChefs && selectedChallenge.bottomChefs.length > 0 && (;<div>;<span className="text-sm text-gray-600 dark:text-gray-400">Bottom Performers</span>;<ul className="mt-1 space-y-1">;{selectedChallenge.bottomChefs.map(chef => (;<li key={chef._id} className="text-gray-700 dark:text-gray-300">;{chef.name};</li>;))};</ul>;</div>;)};</div>;{selectedChallenge.eliminatedChef && (;<div className="mt-4">;<span className="text-sm text-gray-600 dark:text-gray-400">Eliminated</span>;<p className="font-medium text-red-600 dark:text-red-400">;{selectedChallenge.eliminatedChef.name};</p>;</div>;)};</div>;)};</div>;</div>;</div>;</div>;)};</div>;);};export default Schedule
--- client/src/pages/Settings.tsx ---
import { useState, useEffect } from 'react';import { useAuth } from '../hooks/useAuth';import { useTheme } from '../hooks/useTheme';import { useLeague } from '../hooks/useLeague';import Card from '../components/ui/Card';import api from '../services/api';import { doc, getDoc, updateDoc } from 'firebase/firestore';import { db } from '../config/firebase';interface LeagueMember {user: string | { _id: string; name: string };role: 'owner' | 'admin' | 'member';};interface ProfileFormData {name: string;email: string;};interface PasswordFormData {currentPassword: string;newPassword: string;confirmPassword: string;};interface PreferenceFormData {emailNotifications: boolean;pushNotifications: boolean;};interface LeagueFormData {leagueName: string;maxMembers: number;maxRosterSize: number;};function Settings() {const { user, updateProfile, error: authError, loading } = useAuth();const { theme, toggleTheme } = useTheme();const { currentLeague, fetchLeagueDetails } = useLeague();const isLeagueAdmin = currentLeague?.members?.some(;(member: LeagueMember) => {const memberId = typeof member.user === 'string' ? member.user : member.user?._id;return memberId === user?._id && (member.role === 'owner' || member.role === 'admin');};);const [profileForm, setProfileForm] = useState<ProfileFormData>({name: user?.name || '',;email: user?.email || '',;});const [passwordForm, setPasswordForm] = useState<PasswordFormData>({currentPassword: '',;newPassword: '',;confirmPassword: '',;});const [preferenceForm, setPreferenceForm] = useState<PreferenceFormData>({emailNotifications: false,;pushNotifications: false,;});const [leagueForm, setLeagueForm] = useState<LeagueFormData>({leagueName: currentLeague?.name || '',;maxMembers: currentLeague?.maxMembers || 10,;maxRosterSize: currentLeague?.maxRosterSize || 5,;});const [section, setSection] = useState<string>('profile');const [formError, setFormError] = useState<string>('');const [formSuccess, setFormSuccess] = useState<string>('');const [submitting, setSubmitting] = useState<boolean>(false);useEffect(() => {if (user) {setProfileForm({name: user.name || '',;email: user.email || '',;});};}, [user]);useEffect(() => {if (currentLeague) {setLeagueForm({leagueName: currentLeague.name || '',;maxMembers: currentLeague.maxMembers || 10,;maxRosterSize: currentLeague.maxRosterSize || 5,;});};}, [currentLeague]);useEffect(() => {const fetchUserPreferences = async () => {if (!user?._id) return;try {const userDocRef = doc(db, 'users', user._id);const userDocSnap = await getDoc(userDocRef);if (userDocSnap.exists()) {const userData = userDocSnap.data();setPreferenceForm({emailNotifications: !!userData.emailNotifications,;pushNotifications: !!userData.pushNotifications,;});};} catch (err) {console.error('Error fetching user preferences:', err);};};fetchUserPreferences();}, [user?._id]);const handleProfileChange = (e: React.ChangeEvent<HTMLInputElement>) => {const { name, value } = e.target;setProfileForm(prev => ({ ...prev, [name]: value }));};const handlePasswordChange = (e: React.ChangeEvent<HTMLInputElement>) => {const { name, value } = e.target;setPasswordForm(prev => ({ ...prev, [name]: value }));};const handlePreferenceChange = (e: React.ChangeEvent<HTMLInputElement>) => {const { name, checked } = e.target;setPreferenceForm(prev => ({ ...prev, [name]: checked }));};const handleLeagueChange = (e: React.ChangeEvent<HTMLInputElement>) => {const { name, value } = e.target;if (name === 'leagueName') {setLeagueForm(prev => ({ ...prev, leagueName: value }));} else if (name === 'maxMembers' || name === 'maxRosterSize') {const numValue = parseInt(value);if (!isNaN(numValue)) {setLeagueForm(prev => ({ ...prev, [name]: numValue }));}};};const handleProfileSubmit = async (e: React.FormEvent<HTMLFormElement>) => {e.preventDefault();setFormError('');setFormSuccess('');setSubmitting(true);try {if (!profileForm.name || !profileForm.email) {throw new Error('Name and email are required');};await updateProfile({name: profileForm.name,;email: profileForm.email;});setFormSuccess('Profile updated successfully');} catch (err) {console.error('Profile update error:', err);setFormError(err instanceof Error ? err.message : 'Failed to update profile');} finally {setSubmitting(false);};};const handlePasswordSubmit = async (e: React.FormEvent<HTMLFormElement>) => {e.preventDefault();setFormError('');setFormSuccess('');setSubmitting(true);try {if (!passwordForm.currentPassword) {throw new Error('Current password is required');};if (passwordForm.newPassword !== passwordForm.confirmPassword) {throw new Error('New passwords do not match');};if (passwordForm.newPassword && passwordForm.newPassword.length < 6) {throw new Error('Password must be at least 6 characters');};await updateProfile({password: passwordForm.newPassword;});setPasswordForm({currentPassword: '',;newPassword: '',;confirmPassword: '';});setFormSuccess('Password updated successfully');} catch (err) {console.error('Password update error:', err);setFormError(err instanceof Error ? err.message : 'Failed to update password');} finally {setSubmitting(false);};};const handlePreferencesSubmit = async (e: React.FormEvent<HTMLFormElement>) => {e.preventDefault();setFormError('');setFormSuccess('');setSubmitting(true);try {if (!user || !user._id) {throw new Error('User not authenticated');};const userRef = doc(db, 'users', user._id);await updateDoc(userRef, {emailNotifications: preferenceForm.emailNotifications,;pushNotifications: preferenceForm.pushNotifications,;});setFormSuccess('Preferences updated successfully');} catch (err) {console.error('Preferences update error:', err);setFormError(err instanceof Error ? err.message : 'Failed to update preferences');} finally {setSubmitting(false);};};const handleLeagueSubmit = async (e: React.FormEvent<HTMLFormElement>) => {e.preventDefault();if (!isLeagueAdmin || !currentLeague?._id) return;setFormError('');setFormSuccess('');setSubmitting(true);try {await api.put(`/leagues/${currentLeague._id}`, {name: leagueForm.leagueName,;maxMembers: leagueForm.maxMembers,;maxRosterSize: leagueForm.maxRosterSize,;});if (currentLeague._id) {await fetchLeagueDetails(currentLeague._id);};setFormSuccess('League settings updated successfully');} catch (err) {console.error('League update error:', err);setFormError(err instanceof Error ? err.message : 'Failed to update league settings');} finally {setSubmitting(false);};};return (;<div className="space-y-6 p-6 bg-gray-50 dark:bg-gray-900 min-h-screen">;<h1 className="text-2xl font-bold text-gray-900 dark:text-white">Settings</h1>;{/* Tabs */};<div className="flex space-x-4 border-b border-gray-200 dark:border-gray-700">;{['profile', 'password', 'preferences', 'league'].map((tab) => (;<button;key={tab};type="button";className={`px-4 py-2 border-b-2 ${section === tab;? 'border-blue-500 text-blue-500';: 'border-transparent text-gray-600 hover:text-gray-900 dark:text-gray-300 dark:hover:text-white';}`};onClick={() => setSection(tab)};aria-pressed={section === tab};>;{tab.charAt(0).toUpperCase() + tab.slice(1)};</button>;))};</div>;{/* Profile Settings */};{section === 'profile' && (;<Card title="Profile Settings">;{(authError || formError) && (;<div className="mb-4 p-3 bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-400 rounded-lg">;{authError || formError};</div>;)};{formSuccess && (;<div className="mb-4 p-3 bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-400 rounded-lg">;{formSuccess};</div>;)};<form onSubmit={handleProfileSubmit} className="space-y-4">;<div className="mb-4">;<label htmlFor="name" className="block mb-2 text-sm font-medium text-gray-700 dark:text-gray-300">;Name;<span className="text-red-500 ml-1">*</span>;</label>;<input;id="name";name="name";type="text";value={profileForm.name};onChange={handleProfileChange};required;className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500 dark:bg-gray-700 dark:text-white";/>;</div>;<div className="mb-4">;<label htmlFor="email" className="block mb-2 text-sm font-medium text-gray-700 dark:text-gray-300">;Email Address;<span className="text-red-500 ml-1">*</span>;</label>;<input;id="email";name="email";type="email";value={profileForm.email};onChange={handleProfileChange};required;className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500 dark:bg-gray-700 dark:text-white";/>;</div>;<button;type="submit";className={`px-4 py-2 bg-primary-600 hover:bg-primary-700 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500 transition-colors ${(submitting || loading) ? 'opacity-60 cursor-not-allowed' : ''}`};disabled={submitting || loading};>;{submitting || loading ? (;<span className="flex items-center">;<svg className="animate-spin h-4 w-4 mr-2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">;<circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>;<path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>;</svg>;Loading...;</span>;) : "Update Profile"};</button>;</form>;</Card>;)};{/* Password Settings */};{section === 'password' && (;<Card title="Password Settings">;{(authError || formError) && (;<div className="mb-4 p-3 bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-400 rounded-lg">;{authError || formError};</div>;)};{formSuccess && (;<div className="mb-4 p-3 bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-400 rounded-lg">;{formSuccess};</div>;)};<form onSubmit={handlePasswordSubmit} className="space-y-4">;<div className="mb-4">;<label htmlFor="currentPassword" className="block mb-2 text-sm font-medium text-gray-700 dark:text-gray-300">;Current Password;<span className="text-red-500 ml-1">*</span>;</label>;<input;id="currentPassword";name="currentPassword";type="password";value={passwordForm.currentPassword};onChange={handlePasswordChange};required;className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500 dark:bg-gray-700 dark:text-white";/>;</div>;<div className="mb-4">;<label htmlFor="newPassword" className="block mb-2 text-sm font-medium text-gray-700 dark:text-gray-300">;New Password;</label>;<input;id="newPassword";name="newPassword";type="password";value={passwordForm.newPassword};onChange={handlePasswordChange};className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500 dark:bg-gray-700 dark:text-white";/>;<p className="mt-1 text-sm text-gray-500 dark:text-gray-400">Password must be at least 6 characters</p>;</div>;<div className="mb-4">;<label htmlFor="confirmPassword" className="block mb-2 text-sm font-medium text-gray-700 dark:text-gray-300">;Confirm New Password;</label>;<input;id="confirmPassword";name="confirmPassword";type="password";value={passwordForm.confirmPassword};onChange={handlePasswordChange};className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500 dark:bg-gray-700 dark:text-white";/>;</div>;<button;type="submit";className={`px-4 py-2 bg-primary-600 hover:bg-primary-700 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500 transition-colors ${(submitting || loading) ? 'opacity-60 cursor-not-allowed' : ''}`};disabled={submitting || loading};>;{submitting || loading ? "Processing..." : "Update Password"};</button>;</form>;</Card>;)};{/* Rest of the component implementation... */};{/* Preferences and League sections follow the same pattern of replacing Input and Button components with native elements */};{/* Preferences */};{section === 'preferences' && (;<div className="space-y-6">;<Card title="Theme Preferences">;<div className="flex items-center justify-between py-2">;<div>;<h3 className="font-medium text-gray-900 dark:text-white">Dark Mode</h3>;<p className="text-sm text-gray-600 dark:text-gray-400">;Toggle between light and dark theme;</p>;</div>;<div className="relative inline-block w-12 h-6">;<input;type="checkbox";id="toggle";name="toggle";checked={theme === 'dark'};onChange={toggleTheme};className="absolute w-0 h-0 opacity-0";aria-label="Toggle dark mode";/>;<label;htmlFor="toggle";className={`block h-6 w-12 rounded-full cursor-pointer transition-colors ${theme === 'dark' ? 'bg-blue-500' : 'bg-gray-300';}`};>;<span;className={`absolute top-0 left-0 w-6 h-6 rounded-full bg-white shadow transform transition-transform duration-200 ease-in-out ${theme === 'dark' ? 'translate-x-6' : 'translate-x-0';}`};></span>;</label>;</div>;</div>;</Card>;<Card title="Notification Preferences">;{(authError || formError) && (;<div className="mb-4 p-3 bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-400 rounded-lg">;{authError || formError};</div>;)};{formSuccess && (;<div className="mb-4 p-3 bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-400 rounded-lg">;{formSuccess};</div>;)};<form onSubmit={handlePreferencesSubmit} className="space-y-4">;<div className="flex items-center justify-between py-2">;<div>;<h3 className="font-medium text-gray-900 dark:text-white">Email Notifications</h3>;<p className="text-sm text-gray-600 dark:text-gray-400">;Receive updates via email;</p>;</div>;<div className="relative inline-block w-12 h-6">;<input;type="checkbox";id="emailNotifications";name="emailNotifications";checked={preferenceForm.emailNotifications};onChange={handlePreferenceChange};className="absolute w-0 h-0 opacity-0";aria-label="Toggle email notifications";/>;<label;htmlFor="emailNotifications";className={`block h-6 w-12 rounded-full cursor-pointer transition-colors ${preferenceForm.emailNotifications ? 'bg-blue-500' : 'bg-gray-300';}`};>;<span;className={`absolute top-0 left-0 w-6 h-6 rounded-full bg-white shadow transform transition-transform duration-200 ease-in-out ${preferenceForm.emailNotifications ? 'translate-x-6' : 'translate-x-0';}`};></span>;</label>;</div>;</div>;<div className="flex items-center justify-between py-2">;<div>;<h3 className="font-medium text-gray-900 dark:text-white">Push Notifications</h3>;<p className="text-sm text-gray-600 dark:text-gray-400">;Receive alerts on your device;</p>;</div>;<div className="relative inline-block w-12 h-6">;<input;type="checkbox";id="pushNotifications";name="pushNotifications";checked={preferenceForm.pushNotifications};onChange={handlePreferenceChange};className="absolute w-0 h-0 opacity-0";aria-label="Toggle push notifications";/>;<label;htmlFor="pushNotifications";className={`block h-6 w-12 rounded-full cursor-pointer transition-colors ${preferenceForm.pushNotifications ? 'bg-blue-500' : 'bg-gray-300';}`};>;<span;className={`absolute top-0 left-0 w-6 h-6 rounded-full bg-white shadow transform transition-transform duration-200 ease-in-out ${preferenceForm.pushNotifications ? 'translate-x-6' : 'translate-x-0';}`};></span>;</label>;</div>;</div>;<button;type="submit";className={`px-4 py-2 bg-primary-600 hover:bg-primary-700 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500 transition-colors ${submitting ? 'opacity-60 cursor-not-allowed' : ''}`};disabled={submitting};>;{submitting ? "Saving..." : "Save Preferences"};</button>;</form>;</Card>;</div>;)};{/* League Settings */};{section === 'league' && (;<Card title="League Settings">;{(authError || formError) && (;<div className="mb-4 p-3 bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-400 rounded-lg">;{authError || formError};</div>;)};{formSuccess && (;<div className="mb-4 p-3 bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-400 rounded-lg">;{formSuccess};</div>;)};{!currentLeague ? (;<p className="text-gray-600 dark:text-gray-400">Select a league to edit its settings.</p>;) : (;<form onSubmit={handleLeagueSubmit} className="space-y-4">;<div className="mb-4">;<label htmlFor="leagueName" className="block mb-2 text-sm font-medium text-gray-700 dark:text-gray-300">;League Name;<span className="text-red-500 ml-1">*</span>;</label>;<input;id="leagueName";name="leagueName";type="text";value={leagueForm.leagueName};onChange={handleLeagueChange};disabled={!isLeagueAdmin};required;className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500 dark:bg-gray-700 dark:text-white disabled:opacity-50 disabled:cursor-not-allowed";/>;</div>;<div className="mb-4">;<label htmlFor="maxMembers" className="block mb-2 text-sm font-medium text-gray-700 dark:text-gray-300">;Max Members;<span className="text-red-500 ml-1">*</span>;</label>;<input;id="maxMembers";name="maxMembers";type="number";min={2};max={20};value={leagueForm.maxMembers};onChange={handleLeagueChange};disabled={!isLeagueAdmin};required;className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500 dark:bg-gray-700 dark:text-white disabled:opacity-50 disabled:cursor-not-allowed";/>;</div>;<div className="mb-4">;<label htmlFor="maxRosterSize" className="block mb-2 text-sm font-medium text-gray-700 dark:text-gray-300">;Max Roster Size;<span className="text-red-500 ml-1">*</span>;</label>;<input;id="maxRosterSize";name="maxRosterSize";type="number";min={1};max={10};value={leagueForm.maxRosterSize};onChange={handleLeagueChange};disabled={!isLeagueAdmin};required;className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500 dark:bg-gray-700 dark:text-white disabled:opacity-50 disabled:cursor-not-allowed";/>;</div>;<button;type="submit";className={`px-4 py-2 bg-primary-600 hover:bg-primary-700 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500 transition-colors ${(!isLeagueAdmin || submitting) ? 'opacity-60 cursor-not-allowed' : ''}`};disabled={!isLeagueAdmin || submitting};>;{submitting ? "Saving..." : "Save League Settings"};</button>;</form>;)};</Card>;)};</div>;);};export default Settings
--- client/src/types/axios-retry.d.ts ---
declare module 'axios-retry' {import { AxiosInstance } from 'axios';interface AxiosRetry {(axios: AxiosInstance, options: {retries?: number;retryDelay?: (retryCount: number) => number;retryCondition?: (error: any) => boolean;}): void;isNetworkOrIdempotentRequestError(error: any): boolean;};const axiosRetry: AxiosRetry;export default axiosRetry;}
--- client/tailwind.config.ts ---
export default {content: [;"./index.html",;"./src/**/*.{js,jsx}",;],;theme: {extend: {colors: {primary: {50: '#fffbeb',;100: '#fef3c7',;200: '#fde68a',;300: '#fcd34d',;400: '#fbbf24',;500: '#f59e0b',;600: '#d97706',;700: '#b45309',;800: '#92400e',;900: '#78350f',;950: '#451a03',;},;gray: {50: '#f9fafb',;100: '#f3f4f6',;200: '#e5e7eb',;300: '#d1d5db',;400: '#9ca3af',;500: '#6b7280',;600: '#4b5563',;700: '#374151',;800: '#1f2937',;900: '#111827',;950: '#030712',;},;},;fontFamily: {sans: ['Inter var', 'ui-sans-serif', 'system-ui', 'sans-serif'],;display: ['Bebas Neue', 'cursive'],;},;boxShadow: {card: '0 2px 12px rgba(0, 0, 0, 0.08)',;'card-hover': '0 8px 30px rgba(0, 0, 0, 0.12)',;},;animation: {'fade-in': 'fadeIn 0.5s ease-in-out',;'slide-up': 'slideUp 0.5s ease-out',;'slide-down': 'slideDown 0.5s ease-out',;pulse: 'pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite',;},;keyframes: {fadeIn: {'0%': { opacity: '0' },;'100%': { opacity: '1' },;},;slideUp: {'0%': { transform: 'translateY(20px)', opacity: '0' },;'100%': { transform: 'translateY(0)', opacity: '1' },;},;slideDown: {'0%': { transform: 'translateY(-20px)', opacity: '0' },;'100%': { transform: 'translateY(0)', opacity: '1' },;},;},;},;},;plugins: [],}
--- client/tsconfig.json ---
{"compilerOptions": {"target": "ESNext",;"useDefineForClassFields": true,;"lib": ["ESNext", "DOM", "DOM.Iterable"],;"module": "ESNext",;"skipLibCheck": true,;"allowJs": false,;"checkJs": false,;"moduleResolution": "bundler",;"esModuleInterop": true,;"allowSyntheticDefaultImports": true,;"allowImportingTsExtensions": false,;"resolveJsonModule": true,;"isolatedModules": true,;"types": ["react", "react-dom",],;"noEmit": true,;"jsx": "react-jsx",;"jsxImportSource": "react",;"sourceMap": true,;"inlineSources": true,;"strict": true,;"noUnusedLocals": true,;"noUnusedParameters": true,;"noFallthroughCasesInSwitch": true,;"baseUrl": ".",;"paths": {"@/*": ["./src/*"];},;"typeRoots": ["./node_modules/@types", "./src/types"];},;"include": ["src", "src/**/*.d.ts", "*.ts", "*.tsx"],;"references": [{ "path": "./tsconfig.node.json" }]}
--- client/tsconfig.node.json ---
{"compilerOptions": {"composite": true,;"skipLibCheck": true,;"module": "ESNext",;"moduleResolution": "bundler",;"allowSyntheticDefaultImports": true,;"target": "ES2020",           // Added for consistency;"types": ["node", "vite/client"] // Added for explicitness;},;"include": ["client/vite.config.js"]}
--- client/vite.config.js ---
import { defineConfig } from 'vite';import react from '@vitejs/plugin-react';import path from 'path';import fs from 'fs';export default defineConfig(({ mode }) => {const env = {VITE_BACKEND_PORT: process.env.VITE_BACKEND_PORT || '5000',;};let backendPort;try {const portFile = fs.readFileSync(path.resolve(__dirname, 'backend-port.json'), 'utf-8');backendPort = JSON.parse(portFile).port || env.VITE_BACKEND_PORT;} catch (e) {backendPort = env.VITE_BACKEND_PORT;};return {plugins: [react()],;resolve: {alias: {'@': path.resolve(__dirname, './src'),;},;},;server: {port: 5173,;proxy: {'/api': {target: `http://localhost:${backendPort}`,;changeOrigin: true,;},;'/socket.io': {target: `http://localhost:${backendPort}`,;ws: true,;},;},;},;esbuild: {target: 'es2020',;},;build: {target: 'es2020',;cssTarget: 'chrome80',;outDir: 'dist',;minify: 'terser',;terserOptions: {compress: {drop_console: false,;},;},;rollupOptions: {output: {manualChunks: {'react-vendor': ['react', 'react-dom', 'react-router-dom'],;'ui-vendor': ['@heroicons/react', 'chart.js', 'react-chartjs-2'],;},;},;},;},;};})