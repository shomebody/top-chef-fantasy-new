=== server + Root Structure ===
top-chef-fantasy/
  .gitignore
  README.md
  server\.env.example
  server\package.json
  server\src\config\db.js
  server\src\config\firebase.js
  server\src\controllers\authController.js
  server\src\controllers\challengeController.js
  server\src\controllers\chefController.js
  server\src\controllers\leagueController.js
  server\src\controllers\messageController.js
  server\src\index.js
  server\src\middleware\authMiddleware.js
  server\src\middleware\errorMiddleware.js
  server\src\models\FirestoreSchema.js
  server\src\models\challengeModel.js
  server\src\models\chefModel.js
  server\src\models\leagueModel.js
  server\src\models\messageModel.js
  server\src\models\userModel.js
  server\src\routes\authRoutes.js
  server\src\routes\challengeRoutes.js
  server\src\routes\chefRoutes.js
  server\src\routes\leagueRoutes.js
  server\src\routes\messageRoutes.js
  server\src\socket\index.js
  server\src\utils\asyncHandler.js
  server\src\utils\tokenUtils.js
  start.bat
  start.sh

=== server + Root Contents ===

--- .gitignore ---
1: # Dependencies
2: node_modules
3: .pnp
4: .pnp.js
5: 
6: # Testing
7: coverage
8: 
9: # Production
10: build
11: dist
12: dist-ssr
13: 
14: # Environment variables
15: .env
16: .env.local
17: .env.development.local
18: .env.test.local
19: .env.production.local
20: 
21: # Logs
22: logs
23: *.log
24: npm-debug.log*
25: yarn-debug.log*
26: yarn-error.log*
27: pnpm-debug.log*
28: lerna-debug.log*
29: 
30: # Editor directories and files
31: .vscode/*
32: !.vscode/extensions.json
33: .idea
34: .DS_Store
35: *.suo
36: *.ntvs*
37: *.njsproj
38: *.sln
39: *.sw?
40: 
41: # Firebase credentials
42: firebase-service-account.json
43: *-service-account.json
44: service-account*.json
45: firebaseConfig.ts

--- README.md ---
1: # Top Chef Fantasy Application
2: 
3: A full-stack application for Top Chef fans to create and join fantasy leagues, draft chefs, track performance, and compete with friends.
4: 
5: ## Technologies Used
6: 
7: ### Frontend
8: - Vite 6.2.2 with React 19.0.10
9: - TailwindCSS for styling
10: - React Router for navigation
11: - Socket.io client for real-time updates
12: 
13: ### Backend
14: - Express.js
15: - MongoDB Atlas for database
16: - Socket.io for real-time communication
17: - JWT authentication
18: 
19: ## Getting Started
20: 
21: ### Prerequisites
22: - Node.js v18+
23: - MongoDB Atlas account
24: 
25: ### Installation
26: 
27: 1. Clone the repository
28: \\\ash
29: git clone https://github.com/yourusername/top-chef-fantasy.git
30: cd top-chef-fantasy
31: \\\
32: 
33: 2. Install dependencies for both frontend and backend
34: \\\ash
35: # Install backend dependencies
36: cd server
37: npm install
38: 
39: # Install frontend dependencies
40: cd ../client
41: npm install
42: \\\
43: 
44: 3. Set up environment variables
45: - Create a .env file in the server directory based on .env.example
46: - Create a .env file in the client directory based on .env.example
47: 
48: 4. Start the development servers
49: \\\ash
50: # Start backend server
51: cd server
52: npm run dev
53: 
54: # Start frontend development server
55: cd ../client
56: npm run dev
57: \\\
58: 
59: 5. Access the application at http://localhost:5173
60: 
61: ## Deployment
62: 
63: The application is set up for deployment on Render.com using the provided render.yaml file.
64: 
65: ## Project Structure
66: 
67: - /client - Frontend React application
68: - /server - Backend Express application
69:   - /src/models - MongoDB schemas
70:   - /src/controllers - API controllers
71:   - /src/routes - API routes
72:   - /src/middleware - Express middleware
73:   - /src/socket - Socket.io implementation
74: 

--- server\.env.example ---
1: # Server Configuration
2: PORT=5000
3: NODE_ENV=development
4: 
5: # MongoDB Configuration
6: MONGODB_URI=mongodb+srv://username:password@cluster0.mongodb.net/topcheffantasy?retryWrites=true&w=majority
7: 
8: # JWT Configuration
9: JWT_SECRET=your_jwt_secret_key_here
10: JWT_EXPIRE=30d
11: 
12: # CORS Configuration
13: CLIENT_URL=http://localhost:5173
14: 

--- server\package.json ---
1: {
2:   "name": "top-chef-fantasy-server",
3:   "version": "1.0.0",
4:   "description": "Backend server for Top Chef Fantasy application",
5:   "main": "src/index.js",
6:   "type": "module",
7:   "scripts": {
8:     "start": "node src/index.js",
9:     "dev": "nodemon src/index.js",
10:     "test": "echo \"Error: no test specified\" && exit 1"
11:   },
12:   "dependencies": {
13:     "bcryptjs": "2.4.3",
14:     "cors": "2.8.5",
15:     "dotenv": "^16.4.5",
16:     "express": "^4.21.2",
17:     "express-validator": "7.0.1",
18:     "firebase-admin": "12.6.0",
19:     "helmet": "7.1.0",
20:     "jsonwebtoken": "9.0.2",
21:     "morgan": "1.10.0",
22:     "portfinder": "1.0.35",
23:     "socket.io": "^4.7.5",
24:     "winston": "^3.17.0"
25:   },
26:   "devDependencies": {
27:     "nodemon": "^3.1.0"
28:   },
29:   "engines": {
30:     "node": ">=22.0.0"
31:   }
32: }
33: 

--- server\src\config\db.js ---
1: import mongoose from 'mongoose';
2: 
3: const connectDB = async () => {
4:   try {
5:     const conn = await mongoose.connect(process.env.MONGODB_URI);
6:     console.log(`MongoDB Connected: ${conn.connection.host}`);
7:   } catch (error) {
8:     console.error("Failed to connect to MongoDB", error);
9:     process.exit(1);
10:   }
11: };
12: 
13: export default connectDB;

--- server\src\config\firebase.js ---
1: import admin from 'firebase-admin';
2: import dotenv from 'dotenv';
3: import { fileURLToPath } from 'url';
4: import path from 'path';
5: import fs from 'fs';
6: 
7: // Load environment variables
8: dotenv.config();
9: 
10: const __dirname = path.dirname(fileURLToPath(import.meta.url));
11: const serviceAccountPath = path.join(__dirname, '../../firebase-service-account.json');
12: 
13: let credential;
14: try {
15:   // Try to read service account file
16:   if (fs.existsSync(serviceAccountPath)) {
17:     const serviceAccount = JSON.parse(fs.readFileSync(serviceAccountPath, 'utf8'));
18:     credential = admin.credential.cert(serviceAccount);
19:   } else if (process.env.FIREBASE_SERVICE_ACCOUNT) {
20:     // Try environment variable (for deployment)
21:     const serviceAccount = JSON.parse(process.env.FIREBASE_SERVICE_ACCOUNT);
22:     credential = admin.credential.cert(serviceAccount);
23:   } else {
24:     // Fallback to application default credentials
25:     console.warn('Using application default credentials. Set up proper service account for production.');
26:     credential = admin.credential.applicationDefault();
27:   }
28:   
29:   admin.initializeApp({
30:     credential,
31:     storageBucket: process.env.FIREBASE_STORAGE_BUCKET || 'your-project-id.appspot.com',
32:   });
33:   
34:   console.log('Firebase Admin initialized successfully');
35: } catch (error) {
36:   console.error(`Error initializing Firebase Admin: ${error.message}`, { stack: error.stack });
37:   throw error; // Re-throw to prevent server from starting with broken Firebase
38: }
39: 
40: export const auth = admin.auth();
41: export const db = admin.firestore();
42: export const storage = admin.storage();
43: export default admin;

--- server\src\controllers\authController.js ---
1: // server/src/controllers/authController.js
2: import { auth, db } from '../config/firebase.js';
3: import { createLogger, format, transports } from 'winston';
4: import asyncHandler from '../utils/asyncHandler.js';
5: 
6: // Configure logging with Winston (consistent with index.js)
7: const logger = createLogger({
8:   level: process.env.NODE_ENV === 'development' ? 'debug' : 'info',
9:   format: format.combine(
10:     format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
11:     format.errors({ stack: true }),
12:     format.json()
13:   ),
14:   transports: [
15:     new transports.Console(),
16:     new transports.File({ filename: 'logs/error.log', level: 'error' }),
17:     new transports.File({ filename: 'logs/combined.log' }),
18:   ],
19: });
20: 
21: // @desc    Register a new user
22: // @route   POST /api/auth/register
23: // @access  Public
24: export const registerUser = asyncHandler(async (req, res) => {
25:   const { name, email, password } = req.body;
26: 
27:   if (!email || !password || !name) {
28:     res.status(400);
29:     throw new Error('Name, email, and password are required');
30:   }
31: 
32:   if (password.length < 6) {
33:     res.status(400);
34:     throw new Error('Password must be at least 6 characters');
35:   }
36: 
37:   try {
38:     const userSnapshot = await db.collection('users').where('email', '==', email.toLowerCase()).get();
39: 
40:     if (!userSnapshot.empty) {
41:       res.status(400);
42:       throw new Error('User already exists');
43:     }
44: 
45:     const userRecord = await auth.createUser({
46:       email: email.toLowerCase(),
47:       password,
48:       displayName: name,
49:     });
50: 
51:     const userId = userRecord.uid;
52:     await db.collection('users').doc(userId).set({
53:       name,
54:       email: email.toLowerCase(),
55:       avatar: '',
56:       isAdmin: false,
57:       leagues: [],
58:       createdAt: admin.firestore.FieldValue.serverTimestamp(),
59:     });
60: 
61:     const token = await auth.createCustomToken(userId);
62: 
63:     res.status(201).json({
64:       _id: userId,
65:       name,
66:       email: email.toLowerCase(),
67:       isAdmin: false,
68:       token,
69:     });
70:   } catch (error) {
71:     logger.error('Registration error:', { message: error.message, stack: error.stack });
72:     res.status(400);
73:     throw new Error(error.message || 'Invalid user data');
74:   }
75: });
76: 
77: // @desc    Login user & get token
78: // @route   POST /api/auth/login
79: // @access  Public
80: export const loginUser = asyncHandler(async (req, res) => {
81:   const { email } = req.body;
82: 
83:   if (!email) {
84:     res.status(400);
85:     throw new Error('Email is required');
86:   }
87: 
88:   try {
89:     const userSnapshot = await db.collection('users').where('email', '==', email.toLowerCase()).limit(1).get();
90: 
91:     if (userSnapshot.empty) {
92:       res.status(401);
93:       throw new Error('Invalid email');
94:     }
95: 
96:     const userDoc = userSnapshot.docs[0];
97:     const userData = userDoc.data();
98:     const userId = userDoc.id;
99: 
100:     const token = await auth.createCustomToken(userId);
101: 
102:     res.json({
103:       _id: userId,
104:       name: userData.name ?? '',
105:       email: userData.email,
106:       isAdmin: userData.isAdmin ?? false,
107:       token,
108:     });
109:   } catch (error) {
110:     logger.error('Login error:', { message: error.message, stack: error.stack });
111:     res.status(401);
112:     throw new Error(error.message || 'Invalid email');
113:   }
114: });
115: 
116: // @desc    Get user profile
117: // @route   GET /api/auth/profile
118: // @access  Private
119: export const getUserProfile = asyncHandler(async (req, res) => {
120:   try {
121:     const userDoc = await db.collection('users').doc(req.user._id).get();
122: 
123:     if (!userDoc.exists) {
124:       res.status(404);
125:       throw new Error('User not found');
126:     }
127: 
128:     const userData = userDoc.data() ?? {};
129: 
130:     res.json({
131:       _id: userDoc.id,
132:       name: userData.name ?? '',
133:       email: userData.email ?? '',
134:       isAdmin: userData.isAdmin ?? false,
135:       avatar: userData.avatar ?? '',
136:     });
137:   } catch (error) {
138:     logger.error('Get profile error:', { message: error.message, stack: error.stack });
139:     res.status(error.status || 500);
140:     throw new Error(error.message || 'Failed to get user profile');
141:   }
142: });
143: 
144: // @desc    Update user profile
145: // @route   PUT /api/auth/profile
146: // @access  Private
147: export const updateUserProfile = asyncHandler(async (req, res) => {
148:   try {
149:     const userRef = db.collection('users').doc(req.user._id);
150:     const userDoc = await userRef.get();
151: 
152:     if (!userDoc.exists) {
153:       res.status(404);
154:       throw new Error('User not found');
155:     }
156: 
157:     const updates = {};
158:     if (req.body.name) updates.name = req.body.name;
159:     if (req.body.email) updates.email = req.body.email.toLowerCase();
160:     if (req.body.avatar) updates.avatar = req.body.avatar;
161: 
162:     if (req.body.password) {
163:       if (req.body.password.length < 6) {
164:         res.status(400);
165:         throw new Error('Password must be at least 6 characters');
166:       }
167:       await auth.updateUser(req.user._id, { password: req.body.password });
168:     }
169: 
170:     if (req.body.name) {
171:       await auth.updateUser(req.user._id, { displayName: req.body.name });
172:     }
173: 
174:     await userRef.update(updates);
175: 
176:     const updatedUserDoc = await userRef.get();
177:     const updatedUserData = updatedUserDoc.data() ?? {};
178: 
179:     const token = await auth.createCustomToken(req.user._id);
180: 
181:     res.json({
182:       _id: updatedUserDoc.id,
183:       name: updatedUserData.name ?? '',
184:       email: updatedUserData.email ?? '',
185:       isAdmin: updatedUserData.isAdmin ?? false,
186:       avatar: updatedUserData.avatar ?? '',
187:       token,
188:     });
189:   } catch (error) {
190:     logger.error('Update profile error:', { message: error.message, stack: error.stack });
191:     res.status(error.status || 500);
192:     throw new Error(error.message || 'Failed to update user profile');
193:   }
194: });
195: 
196: // @desc    Get all users
197: // @route   GET /api/auth/users
198: // @access  Private/Admin
199: export const getUsers = asyncHandler(async (req, res) => {
200:   try {
201:     const usersSnapshot = await db.collection('users').get();
202: 
203:     const users = usersSnapshot.docs.map((doc) => {
204:       const userData = doc.data() ?? {};
205:       return {
206:         _id: doc.id,
207:         name: userData.name ?? '',
208:         email: userData.email ?? '',
209:         isAdmin: userData.isAdmin ?? false,
210:         avatar: userData.avatar ?? '',
211:       };
212:     });
213: 
214:     res.json(users);
215:   } catch (error) {
216:     logger.error('Get users error:', { message: error.message, stack: error.stack });
217:     res.status(500);
218:     throw new Error('Failed to get users');
219:   }
220: });

--- server\src\controllers\challengeController.js ---
1: import { db } from '../config/firebase.js';
2: import asyncHandler from '../utils/asyncHandler.js';
3: 
4: // @desc    Get all challenges
5: // @route   GET /api/challenges
6: // @access  Private
7: export const getChallenges = asyncHandler(async (req, res) => {
8:   try {
9:     const { season } = req.query;
10:     
11:     let challengesQuery = db.collection('challenges');
12:     
13:     if (season) {
14:       challengesQuery = challengesQuery.where('season', '==', parseInt(season));
15:     }
16:     
17:     const challengesSnapshot = await challengesQuery.orderBy('season').orderBy('week').get();
18:     
19:     const challenges = [];
20:     const chefPromises = [];
21:     
22:     challengesSnapshot.forEach(doc => {
23:       const challenge = { 
24:         _id: doc.id,
25:         ...doc.data()
26:       };
27:       challenges.push(challenge);
28:     });
29:     
30:     // Populate chef references
31:     for (const challenge of challenges) {
32:       if (challenge.winner) {
33:         const winnerDoc = await db.collection('chefs').doc(challenge.winner).get();
34:         if (winnerDoc.exists) {
35:           challenge.winner = { 
36:             _id: winnerDoc.id, 
37:             name: winnerDoc.data().name, 
38:             image: winnerDoc.data().image 
39:           };
40:         }
41:       }
42:       
43:       if (challenge.topChefs && challenge.topChefs.length > 0) {
44:         const topChefDocs = await Promise.all(
45:           challenge.topChefs.map(chefId => db.collection('chefs').doc(chefId).get())
46:         );
47:         
48:         challenge.topChefs = topChefDocs
49:           .filter(doc => doc.exists)
50:           .map(doc => ({ 
51:             _id: doc.id, 
52:             name: doc.data().name, 
53:             image: doc.data().image 
54:           }));
55:       }
56:       
57:       if (challenge.bottomChefs && challenge.bottomChefs.length > 0) {
58:         const bottomChefDocs = await Promise.all(
59:           challenge.bottomChefs.map(chefId => db.collection('chefs').doc(chefId).get())
60:         );
61:         
62:         challenge.bottomChefs = bottomChefDocs
63:           .filter(doc => doc.exists)
64:           .map(doc => ({ 
65:             _id: doc.id, 
66:             name: doc.data().name, 
67:             image: doc.data().image 
68:           }));
69:       }
70:       
71:       if (challenge.eliminatedChef) {
72:         const eliminatedChefDoc = await db.collection('chefs').doc(challenge.eliminatedChef).get();
73:         if (eliminatedChefDoc.exists) {
74:           challenge.eliminatedChef = { 
75:             _id: eliminatedChefDoc.id, 
76:             name: eliminatedChefDoc.data().name, 
77:             image: eliminatedChefDoc.data().image 
78:           };
79:         }
80:       }
81:     }
82:     
83:     res.json(challenges);
84:   } catch (error) {
85:     console.error('Error fetching challenges:', error);
86:     res.status(500).json({ message: 'Failed to fetch challenges' });
87:   }
88: });
89: 
90: // @desc    Get a challenge by ID
91: // @route   GET /api/challenges/:id
92: // @access  Private
93: export const getChallengeById = asyncHandler(async (req, res) => {
94:   try {
95:     const challengeDoc = await db.collection('challenges').doc(req.params.id).get();
96:     
97:     if (!challengeDoc.exists) {
98:       res.status(404);
99:       throw new Error('Challenge not found');
100:     }
101:     
102:     const challenge = {
103:       _id: challengeDoc.id,
104:       ...challengeDoc.data()
105:     };
106:     
107:     // Populate chef references
108:     if (challenge.winner) {
109:       const winnerDoc = await db.collection('chefs').doc(challenge.winner).get();
110:       if (winnerDoc.exists) {
111:         challenge.winner = { 
112:           _id: winnerDoc.id, 
113:           name: winnerDoc.data().name, 
114:           image: winnerDoc.data().image 
115:         };
116:       }
117:     }
118:     
119:     if (challenge.topChefs && challenge.topChefs.length > 0) {
120:       const topChefDocs = await Promise.all(
121:         challenge.topChefs.map(chefId => db.collection('chefs').doc(chefId).get())
122:       );
123:       
124:       challenge.topChefs = topChefDocs
125:         .filter(doc => doc.exists)
126:         .map(doc => ({ 
127:           _id: doc.id, 
128:           name: doc.data().name, 
129:           image: doc.data().image 
130:         }));
131:     }
132:     
133:     if (challenge.bottomChefs && challenge.bottomChefs.length > 0) {
134:       const bottomChefDocs = await Promise.all(
135:         challenge.bottomChefs.map(chefId => db.collection('chefs').doc(chefId).get())
136:       );
137:       
138:       challenge.bottomChefs = bottomChefDocs
139:         .filter(doc => doc.exists)
140:         .map(doc => ({ 
141:           _id: doc.id, 
142:           name: doc.data().name, 
143:           image: doc.data().image 
144:         }));
145:     }
146:     
147:     if (challenge.eliminatedChef) {
148:       const eliminatedChefDoc = await db.collection('chefs').doc(challenge.eliminatedChef).get();
149:       if (eliminatedChefDoc.exists) {
150:         challenge.eliminatedChef = { 
151:           _id: eliminatedChefDoc.id, 
152:           name: eliminatedChefDoc.data().name, 
153:           image: eliminatedChefDoc.data().image 
154:         };
155:       }
156:     }
157:     
158:     res.json(challenge);
159:   } catch (error) {
160:     console.error('Error fetching challenge:', error);
161:     res.status(error.status || 500);
162:     throw new Error(error.message || 'Failed to fetch challenge');
163:   }
164: });
165: 
166: // @desc    Create a challenge (admin only)
167: // @route   POST /api/challenges
168: // @access  Private/Admin
169: export const createChallenge = asyncHandler(async (req, res) => {
170:   const {
171:     season,
172:     week,
173:     title,
174:     description,
175:     location,
176:     isQuickfire,
177:     guest,
178:     airDate
179:   } = req.body;
180:   
181:   try {
182:     const challengeData = {
183:       season: parseInt(season),
184:       week: parseInt(week),
185:       title,
186:       description,
187:       location,
188:       isQuickfire: isQuickfire || false,
189:       guest: guest || '',
190:       winner: null,
191:       topChefs: [],
192:       bottomChefs: [],
193:       eliminatedChef: null,
194:       airDate: new Date(airDate).toISOString(),
195:       status: 'upcoming',
196:       createdAt: new Date().toISOString()
197:     };
198:     
199:     const challengeRef = db.collection('challenges').doc();
200:     await challengeRef.set(challengeData);
201:     
202:     const challenge = {
203:       _id: challengeRef.id,
204:       ...challengeData
205:     };
206:     
207:     res.status(201).json(challenge);
208:   } catch (error) {
209:     console.error('Error creating challenge:', error);
210:     res.status(500);
211:     throw new Error('Failed to create challenge');
212:   }
213: });
214: 
215: // @desc    Update a challenge (admin only)
216: // @route   PUT /api/challenges/:id
217: // @access  Private/Admin
218: export const updateChallenge = asyncHandler(async (req, res) => {
219:   try {
220:     const challengeRef = db.collection('challenges').doc(req.params.id);
221:     const challengeDoc = await challengeRef.get();
222:     
223:     if (!challengeDoc.exists) {
224:       res.status(404);
225:       throw new Error('Challenge not found');
226:     }
227:     
228:     const updates = {};
229:     
230:     // Basic fields
231:     if (req.body.title !== undefined) updates.title = req.body.title;
232:     if (req.body.description !== undefined) updates.description = req.body.description;
233:     if (req.body.location !== undefined) updates.location = req.body.location;
234:     if (req.body.isQuickfire !== undefined) updates.isQuickfire = req.body.isQuickfire;
235:     if (req.body.guest !== undefined) updates.guest = req.body.guest;
236:     if (req.body.airDate !== undefined) updates.airDate = new Date(req.body.airDate).toISOString();
237:     if (req.body.status !== undefined) updates.status = req.body.status;
238:     
239:     // Chef references
240:     if (req.body.winner !== undefined) updates.winner = req.body.winner;
241:     if (req.body.topChefs !== undefined) updates.topChefs = req.body.topChefs;
242:     if (req.body.bottomChefs !== undefined) updates.bottomChefs = req.body.bottomChefs;
243:     if (req.body.eliminatedChef !== undefined) updates.eliminatedChef = req.body.eliminatedChef;
244:     
245:     // Update challenge
246:     await challengeRef.update(updates);
247:     
248:     // Get updated challenge
249:     const updatedChallengeDoc = await challengeRef.get();
250:     const updatedChallenge = {
251:       _id: updatedChallengeDoc.id,
252:       ...updatedChallengeDoc.data()
253:     };
254:     
255:     // Populate chef references (same as in getChallengeById)
256:     if (updatedChallenge.winner) {
257:       const winnerDoc = await db.collection('chefs').doc(updatedChallenge.winner).get();
258:       if (winnerDoc.exists) {
259:         updatedChallenge.winner = { 
260:           _id: winnerDoc.id, 
261:           name: winnerDoc.data().name, 
262:           image: winnerDoc.data().image 
263:         };
264:       }
265:     }
266:     
267:     if (updatedChallenge.topChefs && updatedChallenge.topChefs.length > 0) {
268:       const topChefDocs = await Promise.all(
269:         updatedChallenge.topChefs.map(chefId => db.collection('chefs').doc(chefId).get())
270:       );
271:       
272:       updatedChallenge.topChefs = topChefDocs
273:         .filter(doc => doc.exists)
274:         .map(doc => ({ 
275:           _id: doc.id, 
276:           name: doc.data().name, 
277:           image: doc.data().image 
278:         }));
279:     }
280:     
281:     if (updatedChallenge.bottomChefs && updatedChallenge.bottomChefs.length > 0) {
282:       const bottomChefDocs = await Promise.all(
283:         updatedChallenge.bottomChefs.map(chefId => db.collection('chefs').doc(chefId).get())
284:       );
285:       
286:       updatedChallenge.bottomChefs = bottomChefDocs
287:         .filter(doc => doc.exists)
288:         .map(doc => ({ 
289:           _id: doc.id, 
290:           name: doc.data().name, 
291:           image: doc.data().image 
292:         }));
293:     }
294:     
295:     if (updatedChallenge.eliminatedChef) {
296:       const eliminatedChefDoc = await db.collection('chefs').doc(updatedChallenge.eliminatedChef).get();
297:       if (eliminatedChefDoc.exists) {
298:         updatedChallenge.eliminatedChef = { 
299:           _id: eliminatedChefDoc.id, 
300:           name: eliminatedChefDoc.data().name, 
301:           image: eliminatedChefDoc.data().image 
302:         };
303:       }
304:     }
305:     
306:     res.json(updatedChallenge);
307:   } catch (error) {
308:     console.error('Error updating challenge:', error);
309:     res.status(error.status || 500);
310:     throw new Error(error.message || 'Failed to update challenge');
311:   }
312: });
313: 
314: // @desc    Get current week's challenges
315: // @route   GET /api/challenges/current
316: // @access  Private
317: export const getCurrentChallenges = asyncHandler(async (req, res) => {
318:   const { season } = req.query;
319:   
320:   if (!season) {
321:     res.status(400);
322:     throw new Error('Season parameter is required');
323:   }
324:   
325:   try {
326:     // Find the most recent challenge by airDate
327:     const latestChallengeQuery = db.collection('challenges')
328:       .where('season', '==', parseInt(season))
329:       .orderBy('airDate', 'desc')
330:       .limit(1);
331:     
332:     const latestChallengeSnapshot = await latestChallengeQuery.get();
333:     
334:     if (latestChallengeSnapshot.empty) {
335:       res.status(404);
336:       throw new Error('No challenges found for this season');
337:     }
338:     
339:     const latestChallenge = {
340:       _id: latestChallengeSnapshot.docs[0].id,
341:       ...latestChallengeSnapshot.docs[0].data()
342:     };
343:     
344:     // Get all challenges from the same week
345:     const currentChallengesQuery = db.collection('challenges')
346:       .where('season', '==', parseInt(season))
347:       .where('week', '==', latestChallenge.week);
348:     
349:     const currentChallengesSnapshot = await currentChallengesQuery.get();
350:     
351:     const currentChallenges = [];
352:     currentChallengesSnapshot.forEach(doc => {
353:       currentChallenges.push({
354:         _id: doc.id,
355:         ...doc.data()
356:       });
357:     });
358:     
359:     // Sort challenges by quickfire first, then airDate
360:     currentChallenges.sort((a, b) => {
361:       if (a.isQuickfire !== b.isQuickfire) {
362:         return a.isQuickfire ? -1 : 1;
363:       }
364:       return new Date(a.airDate) - new Date(b.airDate);
365:     });
366:     
367:     // Populate chef references (same as in getChallenges)
368:     for (const challenge of currentChallenges) {
369:       if (challenge.winner) {
370:         const winnerDoc = await db.collection('chefs').doc(challenge.winner).get();
371:         if (winnerDoc.exists) {
372:           challenge.winner = { 
373:             _id: winnerDoc.id, 
374:             name: winnerDoc.data().name, 
375:             image: winnerDoc.data().image 
376:           };
377:         }
378:       }
379:       
380:       if (challenge.topChefs && challenge.topChefs.length > 0) {
381:         const topChefDocs = await Promise.all(
382:           challenge.topChefs.map(chefId => db.collection('chefs').doc(chefId).get())
383:         );
384:         
385:         challenge.topChefs = topChefDocs
386:           .filter(doc => doc.exists)
387:           .map(doc => ({ 
388:             _id: doc.id, 
389:             name: doc.data().name, 
390:             image: doc.data().image 
391:           }));
392:       }
393:       
394:       if (challenge.bottomChefs && challenge.bottomChefs.length > 0) {
395:         const bottomChefDocs = await Promise.all(
396:           challenge.bottomChefs.map(chefId => db.collection('chefs').doc(chefId).get())
397:         );
398:         
399:         challenge.bottomChefs = bottomChefDocs
400:           .filter(doc => doc.exists)
401:           .map(doc => ({ 
402:             _id: doc.id, 
403:             name: doc.data().name, 
404:             image: doc.data().image 
405:           }));
406:       }
407:       
408:       if (challenge.eliminatedChef) {
409:         const eliminatedChefDoc = await db.collection('chefs').doc(challenge.eliminatedChef).get();
410:         if (eliminatedChefDoc.exists) {
411:           challenge.eliminatedChef = { 
412:             _id: eliminatedChefDoc.id, 
413:             name: eliminatedChefDoc.data().name, 
414:             image: eliminatedChefDoc.data().image 
415:           };
416:         }
417:       }
418:     }
419:     
420:     res.json(currentChallenges);
421:   } catch (error) {
422:     console.error('Error fetching current challenges:', error);
423:     res.status(error.status || 500);
424:     throw new Error(error.message || 'Failed to fetch current challenges');
425:   }
426: });

--- server\src\controllers\chefController.js ---
1: // server/src/controllers/chefController.js
2: import admin, { db } from '../config/firebase.js';
3: import { createLogger, format, transports } from 'winston';
4: import asyncHandler from '../utils/asyncHandler.js';
5: 
6: // Configure logging with Winston
7: const logger = createLogger({
8:   level: process.env.NODE_ENV === 'development' ? 'debug' : 'info',
9:   format: format.combine(
10:     format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
11:     format.errors({ stack: true }),
12:     format.json()
13:   ),
14:   transports: [
15:     new transports.Console(),
16:     new transports.File({ filename: 'logs/error.log', level: 'error' }),
17:     new transports.File({ filename: 'logs/combined.log' }),
18:   ],
19: });
20: 
21: // @desc    Get all chefs
22: // @route   GET /api/chefs
23: // @access  Private
24: export const getChefs = asyncHandler(async (req, res) => {
25:   try {
26:     const chefsSnapshot = await db.collection('chefs')
27:       .orderBy('stats.totalPoints', 'desc')
28:       .get();
29: 
30:     const chefs = chefsSnapshot.docs.map((doc) => ({
31:       _id: doc.id,
32:       ...doc.data(),
33:     }));
34: 
35:     res.json(chefs);
36:   } catch (error) {
37:     logger.error('Error fetching chefs:', { message: error.message, stack: error.stack });
38:     throw new Error('Failed to fetch chefs');
39:   }
40: });
41: 
42: // @desc    Get a chef by ID
43: // @route   GET /api/chefs/:id
44: // @access  Private
45: export const getChefById = asyncHandler(async (req, res) => {
46:   try {
47:     const chefDoc = await db.collection('chefs').doc(req.params.id).get();
48: 
49:     if (!chefDoc.exists) {
50:       throw new Error('Chef not found');
51:     }
52: 
53:     const chefData = chefDoc.data() ?? {};
54:     res.json({
55:       _id: chefDoc.id,
56:       name: chefData.name ?? '',
57:       bio: chefData.bio ?? '',
58:       hometown: chefData.hometown ?? '',
59:       specialty: chefData.specialty ?? '',
60:       image: chefData.image ?? '',
61:       status: chefData.status ?? 'active',
62:       eliminationWeek: chefData.eliminationWeek ?? null,
63:       stats: chefData.stats ?? { wins: 0, eliminations: 0, quickfireWins: 0, challengeWins: 0, totalPoints: 0 },
64:       weeklyPerformance: chefData.weeklyPerformance ?? [],
65:     });
66:   } catch (error) {
67:     logger.error('Error fetching chef:', { message: error.message, stack: error.stack });
68:     throw new Error(error.message || 'Failed to fetch chef');
69:   }
70: });
71: 
72: // @desc    Get chef stats by ID
73: // @route   GET /api/chefs/:id/stats
74: // @access  Private
75: export const getChefStats = asyncHandler(async (req, res) => {
76:   try {
77:     const chefDoc = await db.collection('chefs').doc(req.params.id).get();
78: 
79:     if (!chefDoc.exists) {
80:       throw new Error('Chef not found');
81:     }
82: 
83:     const chefData = chefDoc.data() ?? {};
84:     const stats = chefData.stats ?? { wins: 0, eliminations: 0, quickfireWins: 0, challengeWins: 0, totalPoints: 0 };
85: 
86:     res.json({
87:       _id: chefDoc.id,
88:       name: chefData.name ?? '',
89:       stats,
90:       weeklyPerformance: chefData.weeklyPerformance ?? [],
91:     });
92:   } catch (error) {
93:     logger.error('Error fetching chef stats:', { message: error.message, stack: error.stack });
94:     throw new Error(error.message || 'Failed to fetch chef stats');
95:   }
96: });
97: 
98: // @desc    Create a chef (admin only)
99: // @route   POST /api/chefs
100: // @access  Private/Admin
101: export const createChef = asyncHandler(async (req, res) => {
102:   const { name, bio, hometown, specialty, image } = req.body;
103: 
104:   if (!name || !hometown || !specialty) {
105:     throw new Error('Name, hometown, and specialty are required');
106:   }
107: 
108:   try {
109:     const chef = {
110:       name,
111:       bio: bio ?? '',
112:       hometown,
113:       specialty,
114:       image: image ?? '',
115:       status: 'active',
116:       eliminationWeek: null,
117:       stats: {
118:         wins: 0,
119:         eliminations: 0,
120:         quickfireWins: 0,
121:         challengeWins: 0,
122:         totalPoints: 0,
123:       },
124:       weeklyPerformance: [],
125:       createdAt: admin.firestore.FieldValue.serverTimestamp(),
126:     };
127: 
128:     const docRef = await db.collection('chefs').add(chef);
129:     const newChef = await docRef.get();
130:     const newChefData = newChef.data() ?? {};
131: 
132:     res.status(201).json({
133:       _id: newChef.id,
134:       name: newChefData.name ?? '',
135:       bio: newChefData.bio ?? '',
136:       hometown: newChefData.hometown ?? '',
137:       specialty: newChefData.specialty ?? '',
138:       image: newChefData.image ?? '',
139:       status: newChefData.status ?? 'active',
140:       eliminationWeek: newChefData.eliminationWeek ?? null,
141:       stats: newChefData.stats ?? { wins: 0, eliminations: 0, quickfireWins: 0, challengeWins: 0, totalPoints: 0 },
142:       weeklyPerformance: newChefData.weeklyPerformance ?? [],
143:     });
144:   } catch (error) {
145:     logger.error('Error creating chef:', { message: error.message, stack: error.stack });
146:     throw new Error('Failed to create chef');
147:   }
148: });
149: 
150: // @desc    Update a chef (admin only)
151: // @route   PUT /api/chefs/:id
152: // @access  Private/Admin
153: export const updateChef = asyncHandler(async (req, res) => {
154:   try {
155:     const chefRef = db.collection('chefs').doc(req.params.id);
156:     const chefDoc = await chefRef.get();
157: 
158:     if (!chefDoc.exists) {
159:       throw new Error('Chef not found');
160:     }
161: 
162:     const updates = {};
163:     if (req.body.name) updates.name = req.body.name;
164:     if (req.body.bio) updates.bio = req.body.bio;
165:     if (req.body.hometown) updates.hometown = req.body.hometown;
166:     if (req.body.specialty) updates.specialty = req.body.specialty;
167:     if (req.body.image) updates.image = req.body.image;
168:     if (req.body.status) updates.status = req.body.status;
169:     if (req.body.eliminationWeek !== undefined) updates.eliminationWeek = req.body.eliminationWeek;
170: 
171:     if (req.body.stats) {
172:       const currentStats = chefDoc.data()?.stats ?? {};
173:       updates.stats = { ...currentStats, ...req.body.stats };
174:     }
175: 
176:     if (req.body.weeklyPerformance) {
177:       updates.weeklyPerformance = admin.firestore.FieldValue.arrayUnion(req.body.weeklyPerformance);
178:     }
179: 
180:     await chefRef.update(updates);
181:     const updatedChef = await chefRef.get();
182:     const updatedChefData = updatedChef.data() ?? {};
183: 
184:     res.json({
185:       _id: updatedChef.id,
186:       name: updatedChefData.name ?? '',
187:       bio: updatedChefData.bio ?? '',
188:       hometown: updatedChefData.hometown ?? '',
189:       specialty: updatedChefData.specialty ?? '',
190:       image: updatedChefData.image ?? '',
191:       status: updatedChefData.status ?? 'active',
192:       eliminationWeek: updatedChefData.eliminationWeek ?? null,
193:       stats: updatedChefData.stats ?? { wins: 0, eliminations: 0, quickfireWins: 0, challengeWins: 0, totalPoints: 0 },
194:       weeklyPerformance: updatedChefData.weeklyPerformance ?? [],
195:     });
196:   } catch (error) {
197:     logger.error('Error updating chef:', { message: error.message, stack: error.stack });
198:     throw new Error(error.message || 'Failed to update chef');
199:   }
200: });
201: 
202: // @desc    Update chef weekly performance (admin only)
203: // @route   PUT /api/chefs/:id/weekly-performance
204: // @access  Private/Admin
205: export const updateWeeklyPerformance = asyncHandler(async (req, res) => {
206:   const { week, points, performanceNotes } = req.body;
207: 
208:   if (!week || points === undefined) {
209:     throw new Error('Week and points are required');
210:   }
211: 
212:   try {
213:     const chefRef = db.collection('chefs').doc(req.params.id);
214:     const chefDoc = await chefRef.get();
215: 
216:     if (!chefDoc.exists) {
217:       throw new Error('Chef not found');
218:     }
219: 
220:     const chefData = chefDoc.data() ?? {};
221:     const currentStats = chefData.stats ?? { wins: 0, eliminations: 0, quickfireWins: 0, challengeWins: 0, totalPoints: 0 };
222:     const newPerformance = {
223:       week,
224:       points,
225:       notes: performanceNotes ?? '',
226:       timestamp: admin.firestore.FieldValue.serverTimestamp(),
227:     };
228: 
229:     await chefRef.update({
230:       weeklyPerformance: admin.firestore.FieldValue.arrayUnion(newPerformance),
231:       'stats.totalPoints': currentStats.totalPoints + points,
232:     });
233: 
234:     const updatedChef = await chefRef.get();
235:     const updatedChefData = updatedChef.data() ?? {};
236: 
237:     res.json({
238:       _id: updatedChef.id,
239:       name: updatedChefData.name ?? '',
240:       bio: updatedChefData.bio ?? '',
241:       hometown: updatedChefData.hometown ?? '',
242:       specialty: updatedChefData.specialty ?? '',
243:       image: updatedChefData.image ?? '',
244:       status: updatedChefData.status ?? 'active',
245:       eliminationWeek: updatedChefData.eliminationWeek ?? null,
246:       stats: updatedChefData.stats ?? { wins: 0, eliminations: 0, quickfireWins: 0, challengeWins: 0, totalPoints: 0 },
247:       weeklyPerformance: updatedChefData.weeklyPerformance ?? [],
248:     });
249:   } catch (error) {
250:     logger.error('Error updating weekly performance:', { message: error.message, stack: error.stack });
251:     throw new Error(error.message || 'Failed to update weekly performance');
252:   }
253: });

--- server\src\controllers\leagueController.js ---
1: import { db } from '../config/firebase.js';
2: import asyncHandler from '../utils/asyncHandler.js';
3: import crypto from 'crypto';
4: 
5: export const createLeague = asyncHandler(async (req, res) => {
6:   const { name, season, maxMembers, maxRosterSize, scoringSettings } = req.body;
7: 
8:   if (!name || !season) {
9:     res.status(400);
10:     throw new Error('Name and season are required');
11:   }
12: 
13:   try {
14:     const inviteCode = crypto.randomBytes(4).toString('hex').toUpperCase();
15:     
16:     // Create league document
17:     const leagueRef = db.collection('leagues').doc();
18:     const userId = req.user._id;
19:     
20:     const leagueData = {
21:       name,
22:       creator: userId,
23:       season,
24:       maxMembers: maxMembers || 10,
25:       maxRosterSize: maxRosterSize || 5,
26:       inviteCode,
27:       scoringSettings: scoringSettings || {
28:         quickfireWin: 10,
29:         challengeWin: 20,
30:         topThree: 5,
31:         bottomThree: -5,
32:         elimination: -15,
33:         finalWinner: 50
34:       },
35:       members: [{
36:         user: userId,
37:         role: 'owner',
38:         score: 0,
39:         joinedAt: new Date().toISOString()
40:       }],
41:       status: 'draft',
42:       currentWeek: 1,
43:       createdAt: new Date().toISOString()
44:     };
45:     
46:     await leagueRef.set(leagueData);
47:     
48:     // Add league to user's leagues
49:     const userRef = db.collection('users').doc(userId);
50:     await userRef.update({
51:       leagues: firebase.firestore.FieldValue.arrayUnion(leagueRef.id)
52:     });
53:     
54:     // Return league with ID
55:     const league = {
56:       _id: leagueRef.id,
57:       ...leagueData
58:     };
59:     
60:     res.status(201).json(league);
61:     
62:     // Emit real-time update if socket function exists
63:     if (typeof req.app.get('emitLeagueUpdate') === 'function') {
64:       req.app.get('emitLeagueUpdate')(leagueRef.id, { members: league.members });
65:     }
66:   } catch (error) {
67:     console.error('Create league error:', error);
68:     res.status(500);
69:     throw new Error('Failed to create league');
70:   }
71: });
72: 
73: export const getUserLeagues = asyncHandler(async (req, res) => {
74:   try {
75:     const userId = req.user._id;
76:     
77:     // Query leagues where user is a member
78:     const leaguesSnapshot = await db.collection('leagues')
79:       .where('members', 'array-contains', { user: userId })
80:       .get();
81:     
82:     if (leaguesSnapshot.empty) {
83:       return res.json([]);
84:     }
85:     
86:     const leagues = [];
87:     leaguesSnapshot.forEach(doc => {
88:       leagues.push({
89:         _id: doc.id,
90:         ...doc.data()
91:       });
92:     });
93:     
94:     // Populate creator and member details
95:     const populatedLeagues = await Promise.all(leagues.map(async (league) => {
96:       // Get creator details
97:       const creatorDoc = await db.collection('users').doc(league.creator).get();
98:       const creator = creatorDoc.exists ? { _id: creatorDoc.id, ...creatorDoc.data() } : null;
99:       
100:       // Get member details
101:       const memberPromises = league.members.map(async (member) => {
102:         const userDoc = await db.collection('users').doc(member.user).get();
103:         return {
104:           ...member,
105:           user: userDoc.exists ? { _id: userDoc.id, ...userDoc.data() } : null
106:         };
107:       });
108:       
109:       const populatedMembers = await Promise.all(memberPromises);
110:       
111:       return {
112:         ...league,
113:         creator: creator ? { name: creator.name, email: creator.email } : null,
114:         members: populatedMembers
115:       };
116:     }));
117:     
118:     res.json(populatedLeagues);
119:   } catch (error) {
120:     console.error('Get user leagues error:', error);
121:     res.status(500);
122:     throw new Error('Failed to fetch leagues');
123:   }
124: });
125: 
126: export const getLeagueById = asyncHandler(async (req, res) => {
127:   try {
128:     const leagueDoc = await db.collection('leagues').doc(req.params.id).get();
129:     
130:     if (!leagueDoc.exists) {
131:       res.status(404);
132:       throw new Error('League not found');
133:     }
134:     
135:     const league = {
136:       _id: leagueDoc.id,
137:       ...leagueDoc.data()
138:     };
139:     
140:     // Check if user is a member
141:     const isMember = league.members.some(m => m.user === req.user._id);
142:     if (!isMember) {
143:       res.status(403);
144:       throw new Error('Not authorized to access this league');
145:     }
146:     
147:     // Populate creator and members
148:     const creatorDoc = await db.collection('users').doc(league.creator).get();
149:     league.creator = creatorDoc.exists ? 
150:       { _id: creatorDoc.id, name: creatorDoc.data().name, email: creatorDoc.data().email } : null;
151:     
152:     // Populate member info
153:     const memberPromises = league.members.map(async (member) => {
154:       const userDoc = await db.collection('users').doc(member.user).get();
155:       return {
156:         ...member,
157:         user: userDoc.exists ? 
158:           { _id: userDoc.id, name: userDoc.data().name, email: userDoc.data().email } : null
159:       };
160:     });
161:     
162:     league.members = await Promise.all(memberPromises);
163:     
164:     // Populate roster chefs
165:     for (const member of league.members) {
166:       if (member.roster && member.roster.length > 0) {
167:         const chefPromises = member.roster.map(async (rosterItem) => {
168:           const chefDoc = await db.collection('chefs').doc(rosterItem.chef).get();
169:           return {
170:             ...rosterItem,
171:             chef: chefDoc.exists ? { _id: chefDoc.id, ...chefDoc.data() } : null
172:           };
173:         });
174:         
175:         member.roster = await Promise.all(chefPromises);
176:       }
177:     }
178:     
179:     res.json(league);
180:   } catch (error) {
181:     console.error('Get league by id error:', error);
182:     res.status(error.status || 500);
183:     throw new Error(error.message || 'Failed to fetch league');
184:   }
185: });
186: 
187: export const updateLeague = asyncHandler(async (req, res) => {
188:   try {
189:     const leagueRef = db.collection('leagues').doc(req.params.id);
190:     const leagueDoc = await leagueRef.get();
191:     
192:     if (!leagueDoc.exists) {
193:       res.status(404);
194:       throw new Error('League not found');
195:     }
196:     
197:     const league = {
198:       _id: leagueDoc.id,
199:       ...leagueDoc.data()
200:     };
201:     
202:     // Check if user is admin
203:     const member = league.members.find(m => m.user === req.user._id);
204:     if (!member || (member.role !== 'owner' && member.role !== 'admin')) {
205:       res.status(403);
206:       throw new Error('Not authorized to update this league');
207:     }
208:     
209:     // Update fields
210:     const updates = {};
211:     if (req.body.name) updates.name = req.body.name;
212:     if (req.body.maxMembers) updates.maxMembers = req.body.maxMembers;
213:     if (req.body.maxRosterSize) updates.maxRosterSize = req.body.maxRosterSize;
214:     if (req.body.scoringSettings) updates.scoringSettings = req.body.scoringSettings;
215:     if (req.body.status) updates.status = req.body.status;
216:     if (req.body.currentWeek) updates.currentWeek = req.body.currentWeek;
217:     
218:     await leagueRef.update(updates);
219:     
220:     // Get updated league
221:     const updatedLeagueDoc = await leagueRef.get();
222:     const updatedLeague = {
223:       _id: updatedLeagueDoc.id,
224:       ...updatedLeagueDoc.data()
225:     };
226:     
227:     res.json(updatedLeague);
228:     
229:     // Emit real-time update
230:     if (typeof req.app.get('emitLeagueUpdate') === 'function') {
231:       req.app.get('emitLeagueUpdate')(req.params.id, updates);
232:     }
233:   } catch (error) {
234:     console.error('Update league error:', error);
235:     res.status(error.status || 500);
236:     throw new Error(error.message || 'Failed to update league');
237:   }
238: });
239: 
240: export const joinLeague = asyncHandler(async (req, res) => {
241:   const { inviteCode } = req.body;
242:   
243:   if (!inviteCode) {
244:     res.status(400);
245:     throw new Error('Invite code is required');
246:   }
247:   
248:   try {
249:     // Find league by invite code
250:     const leaguesSnapshot = await db.collection('leagues')
251:       .where('inviteCode', '==', inviteCode)
252:       .limit(1)
253:       .get();
254:     
255:     if (leaguesSnapshot.empty) {
256:       res.status(404);
257:       throw new Error('League not found with that invite code');
258:     }
259:     
260:     const leagueDoc = leaguesSnapshot.docs[0];
261:     const league = {
262:       _id: leagueDoc.id,
263:       ...leagueDoc.data()
264:     };
265:     
266:     // Check if league is full
267:     if (league.members.length >= league.maxMembers) {
268:       res.status(400);
269:       throw new Error('League is full');
270:     }
271:     
272:     // Check if user is already a member
273:     const userId = req.user._id;
274:     const isMember = league.members.some(m => m.user === userId);
275:     
276:     if (isMember) {
277:       res.status(400);
278:       throw new Error('You are already a member of this league');
279:     }
280:     
281:     // Add user to league
282:     const newMember = {
283:       user: userId,
284:       role: 'member',
285:       score: 0,
286:       joinedAt: new Date().toISOString()
287:     };
288:     
289:     await leagueDoc.ref.update({
290:       members: firebase.firestore.FieldValue.arrayUnion(newMember)
291:     });
292:     
293:     // Add league to user's leagues
294:     await db.collection('users').doc(userId).update({
295:       leagues: firebase.firestore.FieldValue.arrayUnion(leagueDoc.id)
296:     });
297:     
298:     // Get updated league
299:     const updatedLeagueDoc = await leagueDoc.ref.get();
300:     const updatedLeague = {
301:       _id: updatedLeagueDoc.id,
302:       ...updatedLeagueDoc.data()
303:     };
304:     
305:     res.json(updatedLeague);
306:     
307:     // Emit real-time update
308:     if (typeof req.app.get('emitLeagueUpdate') === 'function') {
309:       req.app.get('emitLeagueUpdate')(leagueDoc.id, { 
310:         members: updatedLeague.members 
311:       });
312:     }
313:   } catch (error) {
314:     console.error('Join league error:', error);
315:     res.status(error.status || 500);
316:     throw new Error(error.message || 'Failed to join league');
317:   }
318: });
319: 
320: export const updateDraftOrder = asyncHandler(async (req, res) => {
321:   const { draftOrder } = req.body;
322:   
323:   try {
324:     const leagueRef = db.collection('leagues').doc(req.params.id);
325:     const leagueDoc = await leagueRef.get();
326:     
327:     if (!leagueDoc.exists) {
328:       res.status(404);
329:       throw new Error('League not found');
330:     }
331:     
332:     const league = leagueDoc.data();
333:     
334:     // Check if user is admin
335:     const member = league.members.find(m => m.user === req.user._id);
336:     if (!member || (member.role !== 'owner' && member.role !== 'admin')) {
337:       res.status(403);
338:       throw new Error('Not authorized to update draft order');
339:     }
340:     
341:     // Update draft order
342:     await leagueRef.update({ draftOrder });
343:     
344:     // Get updated league
345:     const updatedLeagueDoc = await leagueRef.get();
346:     const updatedLeague = {
347:       _id: updatedLeagueDoc.id,
348:       ...updatedLeagueDoc.data()
349:     };
350:     
351:     res.json(updatedLeague);
352:     
353:     // Emit real-time update
354:     if (typeof req.app.get('emitLeagueUpdate') === 'function') {
355:       req.app.get('emitLeagueUpdate')(req.params.id, { draftOrder });
356:     }
357:   } catch (error) {
358:     console.error('Update draft order error:', error);
359:     res.status(error.status || 500);
360:     throw new Error(error.message || 'Failed to update draft order');
361:   }
362: });
363: 
364: export const draftChef = asyncHandler(async (req, res) => {
365:   const { chefId } = req.body;
366:   
367:   if (!chefId) {
368:     res.status(400);
369:     throw new Error('Chef ID is required');
370:   }
371:   
372:   try {
373:     const leagueRef = db.collection('leagues').doc(req.params.id);
374:     const leagueDoc = await leagueRef.get();
375:     
376:     if (!leagueDoc.exists) {
377:       res.status(404);
378:       throw new Error('League not found');
379:     }
380:     
381:     const league = {
382:       _id: leagueDoc.id,
383:       ...leagueDoc.data()
384:     };
385:     
386:     // Check if league is in draft mode
387:     if (league.status !== 'draft') {
388:       res.status(400);
389:       throw new Error('League is not in draft mode');
390:     }
391:     
392:     // Find member
393:     const userId = req.user._id;
394:     const memberIndex = league.members.findIndex(m => m.user === userId);
395:     
396:     if (memberIndex === -1) {
397:       res.status(403);
398:       throw new Error('You are not a member of this league');
399:     }
400:     
401:     const member = league.members[memberIndex];
402:     
403:     // Check if roster is full
404:     if (member.roster && member.roster.length >= league.maxRosterSize) {
405:       res.status(400);
406:       throw new Error('Your roster is full');
407:     }
408:     
409:     // Check if chef is already drafted
410:     const chefDrafted = league.members.some(m => 
411:       m.roster && m.roster.some(r => r.chef === chefId)
412:     );
413:     
414:     if (chefDrafted) {
415:       res.status(400);
416:       throw new Error('This chef has already been drafted');
417:     }
418:     
419:     // Add chef to roster
420:     const newRoster = [...(member.roster || []), {
421:       chef: chefId,
422:       drafted: new Date().toISOString(),
423:       active: true
424:     }];
425:     
426:     // Update the member's roster
427:     league.members[memberIndex].roster = newRoster;
428:     
429:     await leagueRef.update({
430:       members: league.members
431:     });
432:     
433:     // Get updated league
434:     const updatedLeagueDoc = await leagueRef.get();
435:     const updatedLeague = {
436:       _id: updatedLeagueDoc.id,
437:       ...updatedLeagueDoc.data()
438:     };
439:     
440:     res.json(updatedLeague);
441:     
442:     // Emit real-time update
443:     if (typeof req.app.get('emitLeagueUpdate') === 'function') {
444:       req.app.get('emitLeagueUpdate')(req.params.id, { 
445:         members: updatedLeague.members 
446:       });
447:     }
448:   } catch (error) {
449:     console.error('Draft chef error:', error);
450:     res.status(error.status || 500);
451:     throw new Error(error.message || 'Failed to draft chef');
452:   }
453: });
454: 
455: export const getLeagueLeaderboard = asyncHandler(async (req, res) => {
456:   try {
457:     const leagueRef = db.collection('leagues').doc(req.params.id);
458:     const leagueDoc = await leagueRef.get();
459:     
460:     if (!leagueDoc.exists) {
461:       res.status(404);
462:       throw new Error('League not found');
463:     }
464:     
465:     const league = {
466:       _id: leagueDoc.id,
467:       ...leagueDoc.data()
468:     };
469:     
470:     // Check if user is a member
471:     const isMember = league.members.some(m => m.user === req.user._id);
472:     if (!isMember) {
473:       res.status(403);
474:       throw new Error('Not authorized to access this league');
475:     }
476:     
477:     // Populate member info for leaderboard
478:     const memberPromises = league.members.map(async (member) => {
479:       const userDoc = await db.collection('users').doc(member.user).get();
480:       const userData = userDoc.exists ? userDoc.data() : null;
481:       
482:       return {
483:         user: {
484:           _id: member.user,
485:           name: userData?.name || 'Unknown',
486:           email: userData?.email || '',
487:           avatar: userData?.avatar || '',
488:         },
489:         score: member.score || 0,
490:         rosterCount: (member.roster?.length || 0)
491:       };
492:     });
493:     
494:     const leaderboard = await Promise.all(memberPromises);
495:     
496:     // Sort by score (highest first)
497:     leaderboard.sort((a, b) => b.score - a.score);
498:     
499:     res.json(leaderboard);
500:   } catch (error) {
501:     console.error('Get leaderboard error:', error);
502:     res.status(error.status || 500);
503:     throw new Error(error.message || 'Failed to fetch leaderboard');
504:   }
505: });

--- server\src\controllers\messageController.js ---
1: // server/src/controllers/messageController.js
2: 
3: import { db } from '../config/firebase.js';
4: import asyncHandler from '../utils/asyncHandler.js';
5: 
6: // @desc    Get messages for a league
7: // @route   GET /api/messages/:leagueId
8: // @access  Private
9: export const getLeagueMessages = asyncHandler(async (req, res) => {
10:   try {
11:     const { leagueId } = req.params;
12:     const { limit = 50, before } = req.query;
13:     
14:     // Check if user is a member of the league
15:     const leagueDoc = await db.collection('leagues').doc(leagueId).get();
16:     
17:     if (!leagueDoc.exists) {
18:       res.status(404);
19:       throw new Error('League not found');
20:     }
21:     
22:     const league = leagueDoc.data();
23:     
24:     // Check if user is a member of the league
25:     const isMember = league.members.some(member => 
26:       member.user === req.user._id
27:     );
28:     
29:     if (!isMember) {
30:       res.status(403);
31:       throw new Error('Not authorized to access this league');
32:     }
33:     
34:     // Build query
35:     let messagesQuery = db.collection('messages')
36:       .where('league', '==', leagueId)
37:       .orderBy('createdAt', 'desc')
38:       .limit(parseInt(limit));
39:     
40:     if (before) {
41:       const beforeDate = new Date(before);
42:       messagesQuery = messagesQuery.where('createdAt', '<', beforeDate);
43:     }
44:     
45:     const messagesSnapshot = await messagesQuery.get();
46:     
47:     // Transform message data
48:     const messages = [];
49:     const userPromises = [];
50:     
51:     messagesSnapshot.forEach(doc => {
52:       messages.push({
53:         _id: doc.id,
54:         ...doc.data()
55:       });
56:     });
57:     
58:     // Populate sender information
59:     for (const message of messages) {
60:       const senderDoc = await db.collection('users').doc(message.sender).get();
61:       if (senderDoc.exists) {
62:         message.sender = {
63:           _id: senderDoc.id,
64:           name: senderDoc.data().name,
65:           email: senderDoc.data().email,
66:           avatar: senderDoc.data().avatar || ''
67:         };
68:       }
69:     }
70:     
71:     // Mark messages as read
72:     const batch = db.batch();
73:     
74:     for (const message of messages) {
75:       if (!message.readBy.includes(req.user._id)) {
76:         const messageRef = db.collection('messages').doc(message._id);
77:         batch.update(messageRef, {
78:           readBy: [...message.readBy, req.user._id]
79:         });
80:       }
81:     }
82:     
83:     await batch.commit();
84:     
85:     res.json(messages);
86:   } catch (error) {
87:     console.error('Get league messages error:', error);
88:     res.status(error.status || 500);
89:     throw new Error(error.message || 'Failed to fetch messages');
90:   }
91: });
92: 
93: // @desc    Create a message
94: // @route   POST /api/messages
95: // @access  Private
96: export const createMessage = asyncHandler(async (req, res) => {
97:   const { leagueId, content, type = 'text' } = req.body;
98:   
99:   try {
100:     // Check if user is a member of the league
101:     const leagueDoc = await db.collection('leagues').doc(leagueId).get();
102:     
103:     if (!leagueDoc.exists) {
104:       res.status(404);
105:       throw new Error('League not found');
106:     }
107:     
108:     const league = leagueDoc.data();
109:     
110:     const isMember = league.members.some(member => 
111:       member.user === req.user._id
112:     );
113:     
114:     if (!isMember) {
115:       res.status(403);
116:       throw new Error('Not authorized to post in this league');
117:     }
118:     
119:     // Create message
120:     const message = {
121:       league: leagueId,
122:       sender: req.user._id,
123:       content,
124:       type,
125:       reactions: {
126:         likes: [],
127:         hearts: []
128:       },
129:       readBy: [req.user._id],  // Sender has read the message by default
130:       createdAt: new Date().toISOString()
131:     };
132:     
133:     const messageRef = await db.collection('messages').add(message);
134:     const messageDoc = await messageRef.get();
135:     
136:     // Get sender data for response
137:     const senderDoc = await db.collection('users').doc(req.user._id).get();
138:     
139:     const completeMessage = {
140:       _id: messageRef.id,
141:       ...messageDoc.data(),
142:       sender: {
143:         _id: senderDoc.id,
144:         name: senderDoc.data().name,
145:         email: senderDoc.data().email,
146:         avatar: senderDoc.data().avatar || ''
147:       }
148:     };
149:     
150:     res.status(201).json(completeMessage);
151:   } catch (error) {
152:     console.error('Create message error:', error);
153:     res.status(error.status || 500);
154:     throw new Error(error.message || 'Failed to create message');
155:   }
156: });
157: 
158: // @desc    Add reaction to a message
159: // @route   POST /api/messages/:id/reaction
160: // @access  Private
161: export const addReaction = asyncHandler(async (req, res) => {
162:   const { reaction } = req.body;
163:   
164:   if (!['likes', 'hearts'].includes(reaction)) {
165:     res.status(400);
166:     throw new Error('Invalid reaction type');
167:   }
168:   
169:   try {
170:     const messageRef = db.collection('messages').doc(req.params.id);
171:     const messageDoc = await messageRef.get();
172:     
173:     if (!messageDoc.exists) {
174:       res.status(404);
175:       throw new Error('Message not found');
176:     }
177:     
178:     const message = messageDoc.data();
179:     
180:     // Check if user has already reacted
181:     const hasReacted = message.reactions[reaction].includes(req.user._id);
182:     
183:     if (hasReacted) {
184:       // Remove reaction
185:       await messageRef.update({
186:         [`reactions.${reaction}`]: message.reactions[reaction].filter(
187:           userId => userId !== req.user._id
188:         )
189:       });
190:     } else {
191:       // Add reaction
192:       await messageRef.update({
193:         [`reactions.${reaction}`]: [...message.reactions[reaction], req.user._id]
194:       });
195:     }
196:     
197:     // Get updated message
198:     const updatedDoc = await messageRef.get();
199:     
200:     res.json({ 
201:       message: 'Reaction updated', 
202:       reactions: updatedDoc.data().reactions 
203:     });
204:   } catch (error) {
205:     console.error('Add reaction error:', error);
206:     res.status(error.status || 500);
207:     throw new Error(error.message || 'Failed to update reaction');
208:   }
209: });
210: 
211: // @desc    Get unread message count
212: // @route   GET /api/messages/unread/:leagueId
213: // @access  Private
214: export const getUnreadCount = asyncHandler(async (req, res) => {
215:   const { leagueId } = req.params;
216:   
217:   try {
218:     // Check if user is a member of the league
219:     const leagueDoc = await db.collection('leagues').doc(leagueId).get();
220:     
221:     if (!leagueDoc.exists) {
222:       res.status(404);
223:       throw new Error('League not found');
224:     }
225:     
226:     const league = leagueDoc.data();
227:     
228:     const isMember = league.members.some(member => 
229:       member.user === req.user._id
230:     );
231:     
232:     if (!isMember) {
233:       res.status(403);
234:       throw new Error('Not authorized to access this league');
235:     }
236:     
237:     // Count unread messages
238:     const unreadQuery = db.collection('messages')
239:       .where('league', '==', leagueId)
240:       .where('sender', '!=', req.user._id)
241:       .where('readBy', 'array-contains-any', [req.user._id]);
242:     
243:     const unreadSnapshot = await unreadQuery.get();
244:     const totalQuery = db.collection('messages')
245:       .where('league', '==', leagueId)
246:       .where('sender', '!=', req.user._id);
247:     
248:     const totalSnapshot = await totalQuery.get();
249:     
250:     const unreadCount = totalSnapshot.size - unreadSnapshot.size;
251:     
252:     res.json({ unreadCount });
253:   } catch (error) {
254:     console.error('Get unread count error:', error);
255:     res.status(error.status || 500);
256:     throw new Error(error.message || 'Failed to get unread count');
257:   }
258: });

--- server\src\index.js ---
1: // server/src/index.js
2: import admin, { db, auth } from './config/firebase.js'; // Fixed import
3: import express from 'express';
4: import http from 'http';
5: import { Server } from 'socket.io';
6: import dotenv from 'dotenv';
7: import cors from 'cors';
8: import helmet from 'helmet';
9: import morgan from 'morgan';
10: import portfinder from 'portfinder';
11: import { createLogger, format, transports } from 'winston';
12: import setupSocket from './socket/index.js';
13: 
14: // Load environment variables
15: dotenv.config();
16: 
17: // Configure logging with Winston
18: const logger = createLogger({
19:   level: process.env.NODE_ENV === 'development' ? 'debug' : 'info',
20:   format: format.combine(
21:     format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
22:     format.errors({ stack: true }),
23:     format.json()
24:   ),
25:   transports: [
26:     new transports.Console(),
27:     new transports.File({ filename: 'logs/error.log', level: 'error' }),
28:     new transports.File({ filename: 'logs/combined.log' }),
29:   ],
30: });
31: 
32: // Graceful shutdown handler
33: const gracefulShutdown = (server, io, signal) => {
34:   logger.info(`Received ${signal}. Starting graceful shutdown...`);
35:   io.close(() => {
36:     logger.info('Socket.IO connections closed.');
37:     server.close(() => {
38:       logger.info('HTTP server closed.');
39:       process.exit(0);
40:     });
41:   });
42: };
43: 
44: // Main server startup function
45: const startServer = async () => {
46:   try {
47:     // Initialize Express app and HTTP server
48:     const app = express();
49:     const server = http.createServer(app);
50: 
51:     // Configure Socket.IO
52:     const io = new Server(server, {
53:       cors: {
54:         origin: process.env.CLIENT_URL || 'http://localhost:5173',
55:         methods: ['GET', 'POST', 'PUT', 'DELETE'],
56:         credentials: true,
57:       },
58:       pingTimeout: 60000,
59:       pingInterval: 25000,
60:     });
61: 
62:     // Setup Socket.IO with Firebase
63:     setupSocket(io, db, auth);
64: 
65:     // Middleware
66:     app.use(express.json({ limit: '10mb' }));
67:     app.use(express.urlencoded({ extended: true }));
68:     app.use(cors({
69:       origin: process.env.CLIENT_URL || 'http://localhost:5173',
70:       methods: ['GET', 'POST', 'PUT', 'DELETE'],
71:       credentials: true,
72:     }));
73:     app.use(helmet({
74:       contentSecurityPolicy: {
75:         directives: {
76:           defaultSrc: ["'self'"],
77:           scriptSrc: ["'self'", "'unsafe-inline'"],
78:         },
79:       },
80:     }));
81:     app.use(morgan('dev', {
82:       stream: { write: (message) => logger.info(message.trim()) },
83:     }));
84: 
85:     // Health check endpoint with Firebase status
86:     app.get('/health', async (req, res) => {
87:       try {
88:         await db.collection('health').doc('status').set({ lastChecked: admin.firestore.FieldValue.serverTimestamp() });
89:         res.status(200).json({
90:           status: 'healthy',
91:           uptime: process.uptime(),
92:           timestamp: new Date().toISOString(),
93:         });
94:       } catch (error) {
95:         logger.error('Health check failed:', error);
96:         res.status(500).json({ status: 'unhealthy', error: error.message });
97:       }
98:     });
99: 
100:     // API Routes (pass db and auth if needed)
101:     app.use('/api/auth', (await import('./routes/authRoutes.js')).default);
102:     app.use('/api/chefs', (await import('./routes/chefRoutes.js')).default);
103:     app.use('/api/leagues', (await import('./routes/leagueRoutes.js')).default);
104:     app.use('/api/challenges', (await import('./routes/challengeRoutes.js')).default);
105:     app.use('/api/messages', (await import('./routes/messageRoutes.js')).default);
106: 
107:     // Welcome route
108:     app.get('/', (req, res) => {
109:       res.send('Top Chef Fantasy API is running...');
110:     });
111: 
112:     // Error handling middleware
113:     app.use((req, res, next) => {
114:       const error = new Error(`Not Found - ${req.originalUrl}`);
115:       res.status(404);
116:       next(error);
117:     });
118:     app.use((err, req, res, next) => {
119:       logger.error(`Server Error: ${err.message}`, { stack: err.stack });
120:       const statusCode = res.statusCode === 200 ? 500 : res.statusCode;
121:       res.status(statusCode).json({
122:         message: err.message,
123:         stack: process.env.NODE_ENV === 'development' ? err.stack : undefined,
124:       });
125:     });
126: 
127:     // Dynamic port finding
128:     const basePort = parseInt(process.env.PORT, 10) || 5000;
129:     portfinder.basePort = basePort;
130:     const port = await portfinder.getPortPromise();
131: 
132:     // Start the server
133:     server.listen(port, () => {
134:       logger.info(`Server running on port ${port} in ${process.env.NODE_ENV || 'development'} mode`);
135:     });
136: 
137:     // Handle server errors
138:     server.on('error', (err) => {
139:       if (err.code === 'EADDRINUSE') {
140:         logger.error(`Port ${port} is in use, attempting to find another...`);
141:         portfinder.getPortPromise().then((newPort) => {
142:           server.listen(newPort, () => {
143:             logger.info(`Server switched to port ${newPort}`);
144:           });
145:         });
146:       } else {
147:         logger.error('Server error:', err);
148:         throw err;
149:       }
150:     });
151: 
152:     // Graceful shutdown
153:     ['SIGINT', 'SIGTERM'].forEach((signal) => {
154:       process.on(signal, () => gracefulShutdown(server, io, signal));
155:     });
156: 
157:     process.on('unhandledRejection', (reason, promise) => {
158:       logger.error('Unhandled Rejection at:', promise, 'reason:', reason);
159:       gracefulShutdown(server, io, 'unhandledRejection');
160:     });
161: 
162:     process.on('uncaughtException', (err) => {
163:       logger.error('Uncaught Exception:', err);
164:       gracefulShutdown(server, io, 'uncaughtException');
165:     });
166: 
167:   } catch (err) {
168:     logger.error('Failed to start server:', err);
169:     process.exit(1);
170:   }
171: };
172: 
173: // Start the server
174: startServer();

--- server\src\middleware\authMiddleware.js ---
1: import { auth } from '../config/firebase.js';
2: import asyncHandler from '../utils/asyncHandler.js';
3: 
4: // Protect routes - verify Firebase token
5: export const protect = asyncHandler(async (req, res, next) => {
6:   let token;
7:   
8:   // Check if token exists in headers
9:   if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
10:     try {
11:       // Get token from header
12:       token = req.headers.authorization.split(' ')[1];
13:       
14:       // Verify token with Firebase Admin
15:       const decodedToken = await auth.verifyIdToken(token);
16:       
17:       // Add user info to request
18:       req.user = {
19:         _id: decodedToken.uid,
20:         email: decodedToken.email || decodedToken.firebase.identities.email?.[0]
21:       };
22:       
23:       next();
24:     } catch (error) {
25:       console.error('Auth middleware error:', error);
26:       res.status(401);
27:       throw new Error('Not authorized, token failed');
28:     }
29:   } else if (!token) {
30:     res.status(401);
31:     throw new Error('Not authorized, no token');
32:   }
33: });
34: 
35: // Admin middleware
36: export const admin = asyncHandler(async (req, res, next) => {
37:   try {
38:     // Get user from Firestore
39:     const userDoc = await auth.getUser(req.user._id);
40:     const userData = (await db.collection('users').doc(req.user._id).get()).data();
41:     
42:     if (userData && userData.isAdmin) {
43:       next();
44:     } else {
45:       res.status(403);
46:       throw new Error('Not authorized as an admin');
47:     }
48:   } catch (error) {
49:     console.error('Admin middleware error:', error);
50:     res.status(403);
51:     throw new Error('Not authorized as an admin');
52:   }
53: });

--- server\src\middleware\errorMiddleware.js ---
1: // Not found middleware
2: export const notFound = (req, res, next) => {
3:   const error = new Error(`Not Found - ${req.originalUrl}`);
4:   res.status(404);
5:   next(error);
6: };
7: 
8: // Error handler middleware
9: export const errorHandler = (err, req, res, next) => {
10:   const statusCode = res.statusCode === 200 ? 500 : res.statusCode;
11:   res.status(statusCode);
12:   res.json({
13:     message: err.message,
14:     stack: process.env.NODE_ENV === 'production' ? null : err.stack,
15:   });
16: };

--- server\src\models\challengeModel.js ---
1: import mongoose from 'mongoose';
2: 
3: const challengeSchema = new mongoose.Schema({
4:   season: { type: Number, required: [true, 'Please provide a season number'] }, // Comma added here
5:   week: { type: Number, required: [true, 'Please provide a week number'] },
6:   title: { type: String, required: [true, 'Please provide a challenge title'] },
7:   description: { type: String, required: [true, 'Please provide a challenge description'] },
8:   location: { type: String, required: [true, 'Please provide a location'] },
9:   isQuickfire: { type: Boolean, default: false },
10:   guest: { type: String, default: '' },
11:   winner: { type: mongoose.Schema.Types.ObjectId, ref: 'Chef', default: null },
12:   topChefs: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Chef' }],
13:   bottomChefs: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Chef' }],
14:   eliminatedChef: { type: mongoose.Schema.Types.ObjectId, ref: 'Chef', default: null },
15:   airDate: { type: Date, required: [true, 'Please provide an air date'] },
16:   status: { type: String, enum: ['upcoming', 'completed'], default: 'upcoming' }
17: }, {
18:   timestamps: true
19: });
20: 
21: const Challenge = mongoose.model('Challenge', challengeSchema);
22: 
23: export default Challenge;

--- server\src\models\chefModel.js ---
1: import mongoose from 'mongoose';
2: 
3: const chefSchema = new mongoose.Schema({
4:   name: { type: String, required: [true, 'Please provide a chef name'], trim: true },
5:   bio: { type: String, required: [true, 'Please provide a chef bio'] },
6:   hometown: { type: String, required: [true, 'Please provide a hometown'] },
7:   specialty: { type: String, required: [true, 'Please provide a specialty'] },
8:   image: { type: String, default: '' },
9:   status: { type: String, enum: ['active', 'eliminated', 'winner'], default: 'active' },
10:   eliminationWeek: { type: Number, default: null },
11:   stats: {
12:     wins: { type: Number, default: 0 },
13:     eliminations: { type: Number, default: 0 },
14:     quickfireWins: { type: Number, default: 0 },
15:     challengeWins: { type: Number, default: 0 },
16:     totalPoints: { type: Number, default: 0 }
17:   },
18:   weeklyPerformance: [{
19:     week: Number,
20:     points: Number,
21:     rank: Number,
22:     highlights: String
23:   }]
24: }, {
25:   timestamps: true
26: });
27: 
28: const Chef = mongoose.models.Chef || mongoose.model('Chef', chefSchema);
29: 
30: export default Chef;

--- server\src\models\FirestoreSchema.js ---
1: /**
2:  * Firestore Database Schema
3:  * 
4:  * This is a reference document for the Firestore data structure.
5:  * No actual code is executed here - this serves as documentation.
6:  */
7: 
8: /**
9:  * Collection: users
10:  * Document ID: UID from Firebase Auth
11:  * {
12:  *   name: string,
13:  *   email: string, 
14:  *   avatar: string,
15:  *   isAdmin: boolean,
16:  *   leagues: Array<string> (league IDs),
17:  *   createdAt: timestamp
18:  * }
19:  */
20: 
21: /**
22:  * Collection: chefs
23:  * Document ID: auto-generated
24:  * {
25:  *   name: string,
26:  *   bio: string,
27:  *   hometown: string,
28:  *   specialty: string,
29:  *   image: string,
30:  *   status: 'active' | 'eliminated' | 'winner',
31:  *   eliminationWeek: number | null,
32:  *   stats: {
33:  *     wins: number,
34:  *     eliminations: number,
35:  *     quickfireWins: number,
36:  *     challengeWins: number,
37:  *     totalPoints: number
38:  *   },
39:  *   weeklyPerformance: [
40:  *     {
41:  *       week: number,
42:  *       points: number,
43:  *       rank: number,
44:  *       highlights: string
45:  *     }
46:  *   ]
47:  * }
48:  */
49: 
50: /**
51:  * Collection: leagues
52:  * Document ID: auto-generated
53:  * {
54:  *   name: string,
55:  *   creator: string (user ID),
56:  *   season: number,
57:  *   maxMembers: number,
58:  *   maxRosterSize: number,
59:  *   status: 'draft' | 'active' | 'completed',
60:  *   inviteCode: string,
61:  *   scoringSettings: {
62:  *     quickfireWin: number,
63:  *     challengeWin: number,
64:  *     topThree: number,
65:  *     bottomThree: number,
66:  *     elimination: number,
67:  *     finalWinner: number
68:  *   },
69:  *   currentWeek: number,
70:  *   createdAt: timestamp
71:  * }
72:  * 
73:  * Subcollection: leagues/{leagueId}/members
74:  * Document ID: user ID
75:  * {
76:  *   role: 'owner' | 'admin' | 'member',
77:  *   score: number,
78:  *   joinedAt: timestamp
79:  * }
80:  * 
81:  * Subcollection: leagues/{leagueId}/members/{userId}/roster
82:  * Document ID: chef ID
83:  * {
84:  *   drafted: timestamp,
85:  *   active: boolean
86:  * }
87:  * 
88:  * Subcollection: leagues/{leagueId}/draftOrder
89:  * Document ID: auto-generated
90:  * {
91:  *   user: string (user ID),
92:  *   position: number
93:  * }
94:  */
95: 
96: /**
97:  * Collection: messages
98:  * Document ID: auto-generated
99:  * {
100:  *   league: string (league ID),
101:  *   sender: string (user ID),
102:  *   content: string,
103:  *   type: 'text' | 'image' | 'system',
104:  *   reactions: {
105:  *     likes: Array<string> (user IDs),
106:  *     hearts: Array<string> (user IDs)
107:  *   },
108:  *   readBy: Array<string> (user IDs),
109:  *   createdAt: timestamp
110:  * }
111:  */
112: 
113: /**
114:  * Collection: challenges
115:  * Document ID: auto-generated
116:  * {
117:  *   season: number,
118:  *   week: number,
119:  *   title: string,
120:  *   description: string,
121:  *   location: string,
122:  *   isQuickfire: boolean,
123:  *   guest: string,
124:  *   winner: string (chef ID) | null,
125:  *   topChefs: Array<string> (chef IDs),
126:  *   bottomChefs: Array<string> (chef IDs),
127:  *   eliminatedChef: string (chef ID) | null,
128:  *   airDate: timestamp,
129:  *   status: 'upcoming' | 'completed'
130:  * }
131:  */
132: 
133: // Export nothing - this is just for documentation
134: export {};

--- server\src\models\leagueModel.js ---
1: import mongoose from 'mongoose';
2: 
3: const leagueSchema = new mongoose.Schema({
4:   name: { type: String, required: [true, 'Please provide a league name'], trim: true },
5:   creator: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
6:   members: [{
7:     user: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
8:     role: { type: String, enum: ['owner', 'admin', 'member'], default: 'member' },
9:     roster: [{
10:       chef: { type: mongoose.Schema.Types.ObjectId, ref: 'Chef' },
11:       drafted: { type: Date, default: Date.now },
12:       active: { type: Boolean, default: true }
13:     }],
14:     score: { type: Number, default: 0 }
15:   }],
16:   season: { type: Number, required: [true, 'Please provide a season number'] },
17:   maxMembers: { type: Number, default: 10 },
18:   maxRosterSize: { type: Number, default: 5 },
19:   status: { type: String, enum: ['draft', 'active', 'completed'], default: 'draft' },
20:   inviteCode: { type: String, required: true, unique: true },
21:   scoringSettings: {
22:     quickfireWin: { type: Number, default: 10 },
23:     challengeWin: { type: Number, default: 20 },
24:     topThree: { type: Number, default: 5 },
25:     bottomThree: { type: Number, default: -5 },
26:     elimination: { type: Number, default: -15 },
27:     finalWinner: { type: Number, default: 50 }
28:   },
29:   draftOrder: [{
30:     user: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
31:     position: Number
32:   }],
33:   currentWeek: { type: Number, default: 1 }
34: }, {
35:   timestamps: true
36: });
37: 
38: const League = mongoose.models.League || mongoose.model('League', leagueSchema);
39: 
40: export default League;

--- server\src\models\messageModel.js ---
1: import mongoose from 'mongoose';
2: 
3: const messageSchema = new mongoose.Schema({
4:   league: { type: mongoose.Schema.Types.ObjectId, ref: 'League', required: true },
5:   sender: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
6:   content: { type: String, required: [true, 'Please provide message content'] },
7:   type: { type: String, enum: ['text', 'image', 'system'], default: 'text' },
8:   reactions: {
9:     likes: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }],
10:     hearts: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }]
11:   },
12:   readBy: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }]
13: }, {
14:   timestamps: true
15: });
16: 
17: const Message = mongoose.models.Message || mongoose.model('Message', messageSchema);
18: 
19: export default Message;

--- server\src\models\userModel.js ---
1: import mongoose from 'mongoose';
2: import bcrypt from 'bcryptjs';
3: 
4: const userSchema = new mongoose.Schema({
5:   name: { type: String, required: [true, 'Please provide a name'], trim: true },
6:   email: { type: String, required: [true, 'Please provide an email'], unique: true, lowercase: true, match: [/^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/, 'Please provide a valid email'] },
7:   password: { type: String, required: [true, 'Please provide a password'], minlength: [6, 'Password must be at least 6 characters'], select: false },
8:   avatar: { type: String, default: '' },
9:   isAdmin: { type: Boolean, default: false },
10:   leagues: [{ type: mongoose.Schema.Types.ObjectId, ref: 'League' }],
11:   createdAt: { type: Date, default: Date.now }
12: }, { timestamps: true });
13: 
14: userSchema.pre('save', async function(next) {
15:   if (!this.isModified('password')) {
16:     next();
17:   }
18:   const salt = await bcrypt.genSalt(10);
19:   this.password = await bcrypt.hash(this.password, salt);
20: });
21: 
22: userSchema.methods.matchPassword = async function(enteredPassword) {
23:   return await bcrypt.compare(enteredPassword, this.password);
24: };
25: 
26: const User = mongoose.models.User || mongoose.model('User', userSchema);
27: 
28: export default User;

--- server\src\routes\authRoutes.js ---
1: import express from 'express';
2: import {
3:   registerUser,
4:   loginUser,
5:   getUserProfile,
6:   updateUserProfile,
7:   getUsers
8: } from '../controllers/authController.js';
9: import { protect, admin } from '../middleware/authMiddleware.js';
10: 
11: const router = express.Router();
12: 
13: // Public routes
14: router.post('/register', registerUser);
15: router.post('/login', loginUser);
16: 
17: // Protected routes
18: router.get('/profile', protect, getUserProfile);
19: router.put('/profile', protect, updateUserProfile);
20: 
21: // Admin routes
22: router.get('/users', protect, admin, getUsers);
23: 
24: export default router;
25: 

--- server\src\routes\challengeRoutes.js ---
1: import express from 'express';
2: import {
3:   getChallenges,
4:   getChallengeById,
5:   createChallenge,
6:   updateChallenge,
7:   getCurrentChallenges
8: } from '../controllers/challengeController.js';
9: import { protect, admin } from '../middleware/authMiddleware.js';
10: 
11: const router = express.Router();
12: 
13: // All routes are protected
14: router.use(protect);
15: 
16: router.route('/')
17:   .get(getChallenges)
18:   .post(admin, createChallenge);
19: 
20: router.get('/current', getCurrentChallenges);
21: 
22: router.route('/:id')
23:   .get(getChallengeById)
24:   .put(admin, updateChallenge);
25: 
26: export default router;
27: 

--- server\src\routes\chefRoutes.js ---
1: // server/src/routes/chefRoutes.js
2: import express from 'express';
3: import { getChefs, getChefById, createChef, updateChef, getChefStats, updateWeeklyPerformance } from '../controllers/chefController.js';
4: 
5: const router = express.Router();
6: 
7: router.get('/', getChefs);
8: router.get('/:id', getChefById);
9: router.post('/', createChef); // Admin only
10: router.put('/:id', updateChef); // Admin only
11: router.get('/:id/stats', getChefStats);
12: router.put('/:id/weekly-performance', updateWeeklyPerformance); // Assumed route causing error
13: 
14: export default router;

--- server\src\routes\leagueRoutes.js ---
1: import express from 'express';
2: import {
3:   createLeague,
4:   getUserLeagues,
5:   getLeagueById,
6:   updateLeague,
7:   joinLeague,
8:   updateDraftOrder,
9:   draftChef,
10:   getLeagueLeaderboard
11: } from '../controllers/leagueController.js';
12: import { protect } from '../middleware/authMiddleware.js';
13: 
14: const router = express.Router();
15: 
16: // All routes are protected
17: router.use(protect);
18: 
19: router.route('/')
20:   .get(getUserLeagues)
21:   .post(createLeague);
22: 
23: router.post('/join', joinLeague);
24: 
25: router.route('/:id')
26:   .get(getLeagueById)
27:   .put(updateLeague);
28: 
29: router.put('/:id/draft-order', updateDraftOrder);
30: router.post('/:id/draft', draftChef);
31: router.get('/:id/leaderboard', getLeagueLeaderboard);
32: 
33: export default router;
34: 

--- server\src\routes\messageRoutes.js ---
1: import express from 'express';
2: import {
3:   getLeagueMessages,
4:   createMessage,
5:   addReaction,
6:   getUnreadCount
7: } from '../controllers/messageController.js';
8: import { protect } from '../middleware/authMiddleware.js';
9: 
10: const router = express.Router();
11: 
12: // All routes are protected
13: router.use(protect);
14: 
15: router.post('/', createMessage);
16: router.get('/:leagueId', getLeagueMessages);
17: router.post('/:id/reaction', addReaction);
18: router.get('/unread/:leagueId', getUnreadCount);
19: 
20: export default router;
21: 

--- server\src\socket\index.js ---
1: import { verifyToken } from '../utils/tokenUtils.js';
2: 
3: // Socket event constants
4: export const EVENTS = {
5:   CONNECTION: 'connection',
6:   DISCONNECT: 'disconnect',
7:   JOIN_LEAGUE: 'join_league',
8:   LEAVE_LEAGUE: 'leave_league',
9:   SEND_MESSAGE: 'send_message',
10:   CHAT_MESSAGE: 'chat_message',
11:   CHEF_UPDATE: 'chef_update',
12:   LEAGUE_UPDATE: 'league_update',
13:   USER_TYPING: 'user_typing',
14:   USER_JOINED: 'user_joined',
15:   USER_LEFT: 'user_left',
16:   SCORE_UPDATE: 'score_update'
17: };
18: 
19: // Setup Socket.io connections and event handlers
20: const setupSocket = (io) => {
21:   // Authenticate Socket.io connections
22:   io.use((socket, next) => {
23:     try {
24:       const token = socket.handshake.auth.token;
25:       if (!token) {
26:         return next(new Error('Authentication error: No token provided'));
27:       }
28:       const user = verifyToken(token);
29:       if (!user) {
30:         return next(new Error('Authentication error: Invalid token'));
31:       }
32:       socket.user = user;
33:       next();
34:     } catch (error) {
35:       console.error('Socket authentication error:', error.stack); // Detailed logging
36:       next(new Error('Authentication error: Invalid token'));
37:     }
38:   });
39: 
40:   // Handle connections
41:   io.on(EVENTS.CONNECTION, (socket) => {
42:     console.log(`User connected: ${socket.user.id}`);
43: 
44:     // Join user's leagues
45:     socket.on(EVENTS.JOIN_LEAGUE, ({ leagueId }) => {
46:       try {
47:         socket.join(`league:${leagueId}`);
48:         console.log(`User ${socket.user.id} joined league: ${leagueId}`);
49:         socket.to(`league:${leagueId}`).emit(EVENTS.USER_JOINED, {
50:           userId: socket.user.id,
51:           username: socket.user.name,
52:           timestamp: new Date()
53:         });
54:       } catch (error) {
55:         console.error('Error in JOIN_LEAGUE:', error.stack);
56:       }
57:     });
58: 
59:     // Leave a league
60:     socket.on(EVENTS.LEAVE_LEAGUE, ({ leagueId }) => {
61:       try {
62:         socket.leave(`league:${leagueId}`);
63:         console.log(`User ${socket.user.id} left league: ${leagueId}`);
64:         socket.to(`league:${leagueId}`).emit(EVENTS.USER_LEFT, {
65:           userId: socket.user.id,
66:           username: socket.user.name,
67:           timestamp: new Date()
68:         });
69:       } catch (error) {
70:         console.error('Error in LEAVE_LEAGUE:', error.stack);
71:       }
72:     });
73: 
74:     // Handle chat messages
75:     socket.on(EVENTS.SEND_MESSAGE, (message) => {
76:       try {
77:         const enhancedMessage = {
78:           ...message,
79:           userId: socket.user.id,
80:           username: socket.user.name,
81:           timestamp: new Date()
82:         };
83:         io.to(`league:${message.leagueId}`).emit(EVENTS.CHAT_MESSAGE, enhancedMessage);
84:       } catch (error) {
85:         console.error('Error in SEND_MESSAGE:', error.stack);
86:       }
87:     });
88: 
89:     // Handle user typing
90:     socket.on(EVENTS.USER_TYPING, ({ leagueId }) => {
91:       try {
92:         socket.to(`league:${leagueId}`).emit(EVENTS.USER_TYPING, {
93:           userId: socket.user.id,
94:           username: socket.user.name
95:         });
96:       } catch (error) {
97:         console.error('Error in USER_TYPING:', error.stack);
98:       }
99:     });
100: 
101:     // Handle disconnection
102:     socket.on(EVENTS.DISCONNECT, () => {
103:       console.log(`User disconnected: ${socket.user.id}`);
104:     });
105:   });
106: };
107: 
108: export default setupSocket;

--- server\src\utils\asyncHandler.js ---
1: const asyncHandler = (fn) => (req, res, next) => {
2:   Promise.resolve(fn(req, res, next)).catch(next);
3: };
4: 
5: export default asyncHandler;
6: 

--- server\src\utils\tokenUtils.js ---
1: import jwt from 'jsonwebtoken';
2: 
3: // Generate JWT
4: export const generateToken = (id) => {
5:   return jwt.sign({ id }, process.env.JWT_SECRET, {
6:     expiresIn: process.env.JWT_EXPIRE || '30d' // Default to 30 days if not set
7:   });
8: };
9: 
10: // Verify JWT
11: export const verifyToken = (token) => {
12:   return jwt.verify(token, process.env.JWT_SECRET);
13: };

--- start.bat ---
1: @echo off
2: echo Starting Top Chef Fantasy application...
3: 
4: echo.
5: echo Starting backend server...
6: start cmd /k "cd server && npm install && npm run dev"
7: 
8: echo.
9: echo Starting frontend development server...
10: start cmd /k "cd client && npm install && npm run dev"
11: 
12: echo.
13: echo Application started successfully!
14: echo Backend: http://localhost:5000
15: echo Frontend: http://localhost:5173

--- start.sh ---
1: #!/bin/bash
2: 
3: echo "Starting Top Chef Fantasy application..."
4: 
5: echo ""
6: echo "Starting backend server..."
7: cd server && npm install && npm run dev &
8: 
9: echo ""
10: echo "Starting frontend development server..."
11: cd client && npm install && npm run dev &
12: 
13: echo ""
14: echo "Application started successfully!"
15: echo "Backend: http://localhost:5000"
16: echo "Frontend: http://localhost:5173"
17: 
